<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2019/07/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Safari播放mp4失败的原因分析]]></title>
      <url>http://yoursite.com/2016/05/31/Safari%E6%92%AD%E6%94%BEmp4%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>最近项目中用系统播放器播放MP4文件出了一个问题，用Safari播不了用Chrome可以播放，细查了原因，发现是服务器的问题，原来服务器不支持Content-Range特性。</p>
<p>Safari首先读取文件类型头来判断视频文件是否支持。</p>
<p>因此，对于不支持这个特性的 HTTP 服务器，Safari 就拒绝在线播放，Chrome无此限制。</p>
<p>解决方案：服务器加上这个特性的支持。</p>
<p>测试服务器是否支持：</p>
<pre><code>curl --range 0-99 [MP4 URL]</code></pre><p>如果返回的是100个字节的内容，说明服务器支持断点续传；否则返回整个文件。</p>
<p>参考<a href="https://developer.apple.com/library/iad/documentation/AppleApplications/Reference/SafariWebContent/CreatingVideoforSafarioniPhone/CreatingVideoforSafarioniPhone.html" target="_blank" rel="noopener">Safari Web Content Guide</a>。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo多Mac同步]]></title>
      <url>http://yoursite.com/2016/05/21/Hexo%E5%A4%9AMac%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>单位和家里两PC，同时都想更新blog。而由于hexo没有后台，而且全部文件都在本地生成，所以如果公司电脑上发表了A文章后回家又写了篇B文章，在家里上传后你会发现只有B文章而A文章没了（因为家里的PC上没有A文章的md文件），所以多台电脑同时用来写文章的时候，需要解决备份问题。</p>
<p>而常用的备份方案无非两种：</p>
<ul>
<li>百度云</li>
<li>Dropbox等网盘云备份</li>
</ul>
<p>以百度云为例<br>优点：免费且操作简单<br>不足：</p>
<ul>
<li>备份后同步比较麻烦，每次另一台电脑上都需要手动下载备份文件夹手动覆盖。</li>
<li>开启云端自动备份的时候，写blog的过程中如果保存了文件，会触发百度云的上传，而上传过程中产生的xxx.cfg文件会让hexo解析失败，导致hexo s生成的本地服务器进程停止，不方便边写边预览<br>因此此方案作废</li>
</ul>
<h2 id="利用第三方的git服务备份"><a href="#利用第三方的git服务备份" class="headerlink" title="利用第三方的git服务备份"></a>利用第三方的git服务备份</h2><p>优点：部署完成后更新方便，hexo 更新完后只需要再更新全站到git即可<br>缺点：部署过程相对比较麻烦，对新手不友好（其实是由于对git的理解不深导致的）<br>国内外现在知名的git服务提供商主要有：<br>github、gitcafe、bitbucket、oschina、coding等</p>
<p>由于blog文件夹里有些插件配置文件会涉及比较敏感的隐私数据（云服务商的appsecret key之类的），所以建议放私有仓库（当然也可以把配置文件单独拿出来然后其余的全部扔到git的公众仓库，这个看人，本文重点也不在于git服务商的选择或者公有私有库之争）<br>上面提及的5家服务商里，github、gitcafe的私有库是收费的，而另外三家的私有库目前免费。各位可以自行选择，我个人选择了oschina</p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>git多网站多账户部署过程可以参考git多网站ssh部署方案</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>这个操作建议在blog进度最新的PC上进行的，否则后面解决冲突会比较麻烦<br>在osc上添加公钥，建立新respo等过程略过不讲。</p>
<p>1、 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件</p>
<p>有些插件或者主题是git上下过来安装的话，每个文件夹下都会有对应的.git 文件夹，记得先删掉，否则会和blog仓库冲突<br>（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。##.git文件夹被删除后整个文件对应的git仓库状态也会被清空##)<br>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/.deploy_git</span></span><br><span class="line"><span class="string">/public</span>  </span><br><span class="line"><span class="string">/_config.yml</span></span><br></pre></td></tr></table></figure>

<p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</p>
<p>2、初始化仓库</p>
<p>blog根目录下执行以下代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin &lt;server&gt;</span></span><br><span class="line">&lt;server&gt;是指在线仓库的地址。origin是本地分支,remote <span class="keyword">add</span><span class="bash">操作会将本地仓库映射到云端</span></span><br></pre></td></tr></table></figure>

<p>3、添加本地文件到仓库并同步到git上</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .  <span class="meta">#添加blog目录下所有文件，注意有个`.`（`.gitignore`声明过的文件不包含在内)</span></span><br><span class="line">git commit -m <span class="string">"first commit"</span> <span class="meta">#添加更新说明</span></span><br><span class="line">git <span class="keyword">push</span> -u origin master <span class="meta">#推送更新到云端服务器</span></span><br></pre></td></tr></table></figure>

<p>在执行这步之前一定要注意检查下.gitignore文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用</p>
<pre><code>git rm -r --cached .</code></pre><p>撤销添加操作。</p>
<p>到这里的时候，云端备份已经完成</p>
<h2 id="同步到另一台电脑"><a href="#同步到另一台电脑" class="headerlink" title="同步到另一台电脑"></a>同步到另一台电脑</h2><p>假设之前将A电脑里的内容备份到git了，现在B电脑准备同步内容。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin <span class="tag">&lt;server&gt;</span> <span class="comment">#将本地文件和云端仓库映射起来。这步不可以跳过</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/<span class="literal">master</span></span><br><span class="line">fetch是将云端所有内容拉取下来。reset则是不做任何合并处理，强制将本地内容指向刚刚同步下来的云端内容（正常pull的话需要考虑不少冲突的问题，比较麻烦。）</span><br></pre></td></tr></table></figure>

<p>更新文章后的同步操作</p>
<p>假设在B电脑上写完了文章，也hexo d -g发布完了，这时候需要将新文章的md文件更新上去。（其实就是提交更新给git，会的可以无视了）<br>同一个bash界面下：</p>
<pre><code>git add .</code></pre><p>这时候可以用git status查看状态，一般会显示刚刚更改过的文件状态。如：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">        modified:   db.json</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">file</span>:   source/_posts/test.md</span><br></pre></td></tr></table></figure>

<p>上面的输出状态即说明’db.json’文件做了更改，source/_posts目录下新增了’test.md’文件。</p>
<p>然后对更改添加说明并推送到远程仓库.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'更新信息'</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<p>当显示类似如下提示的时候，即表示备份成功</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To git@git<span class="selector-class">.oschina</span><span class="selector-class">.net</span>:xxxx/blog-backup.git</span><br><span class="line"> + <span class="number">2</span>c77e1e...<span class="number">5616</span>bc6 master -&gt; master (forced update)</span><br></pre></td></tr></table></figure>

<p>再到A电脑上的时候，只需要</p>
<pre><code>git pull</code></pre><p>即可同步更新</p>
<h2 id="给git配置sock5代理"><a href="#给git配置sock5代理" class="headerlink" title="给git配置sock5代理"></a>给git配置sock5代理</h2><p>由于某些众所周知的缘故，所以github时不时的有时候速度会很慢，这种情况下本地代理就派上用场了。<br>这里以给git的SSH传输方式配置本地SS代理为例说下配置过程：</p>
<p>1、打开~/.ssh/config文件。<br>2、在Host github *.github.com下添加以下字段：</p>
<pre><code>Proxycommand ssh -S 127.0.0.1:1080 %h %p</code></pre><p>3、测试连接<br>保存退出后重启git bash。<br>输入ssh -vT <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，当返回Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.的时候即说明配置成功<br>之后github的所有流量都会走本地的ss代理。</p>
<hr>
<p><a href="http://chitanda.me/2015/06/18/hexo-sync-in-multiple-pc/" target="_blank" rel="noopener">原文</a></p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[响应者链深入剖析]]></title>
      <url>http://yoursite.com/2016/05/20/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="一、事件分类"><a href="#一、事件分类" class="headerlink" title="一、事件分类"></a>一、事件分类</h2><p>对于IOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：</p>
<p>1、触屏事件（Touch Event）</p>
<p>2、运动事件（Motion Event）</p>
<p>3、远端控制事件（Remote-Control Event）</p>
<p>今天以触屏事件（Touch Event）为例，来说明在Cocoa Touch框架中，事件的处理流程。首先不得不先介绍响应者链这个概念：</p>
<h2 id="二、响应者链（Responder-Chain）"><a href="#二、响应者链（Responder-Chain）" class="headerlink" title="二、响应者链（Responder Chain）"></a>二、响应者链（Responder Chain）</h2><p>先来说说响应者对象（Responder Object），顾名思义，指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。</p>
<p>UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。图一展示了响应者链的基本构成：</p>
<p><img src="http://f.cl.ly/items/1o0e191K2Y0t1A473V2o/Image%202016-05-18%20at%206.50.57%20PM.png" alt="img"></p>
<p>从图一中可以看到，响应者链有以下特点：</p>
<p>1、响应者链通常是由响应者对象构成的；</p>
<p>2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
<p>3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
<p>4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者</p>
<p>需要指出的是，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点；</p>
<p>5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
<h2 id="三、事件分发（Event-Delivery）"><a href="#三、事件分发（Event-Delivery）" class="headerlink" title="三、事件分发（Event Delivery）"></a>三、事件分发（Event Delivery）</h2><h3 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h3><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。</p>
<p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p>
<p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。<br>hitTest:withEvent:方法的处理流程如下:<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/0v1l1b363b2A0S1w3x01/Image%202016-05-18%20at%207.00.34%20PM.png" alt="img"></p>
<p>假如用户点击了View E，下面介绍hit-test view的流程：</p>
<p>1、A是UIWindow的根视图，因此，UIWindwo对象会首相对A进行hit-test；</p>
<p>2、显然用户点击的范围是在A的范围内，因此，pointInside:withEvent:返回了YES，这时会继续检查A的子视图；</p>
<p>3、这时候会有两个分支，B和C：</p>
<p>点击的范围不再B内，因此B分支的pointInside:withEvent:返回NO，对应的hitTest:withEvent:返回nil；</p>
<p>点击的范围在C内，即C的pointInside:withEvent:返回YES；</p>
<p>4、这时候有D和E两个分支：</p>
<p>点击的范围不再D内，因此D的pointInside:withEvent:返回NO，对应的hitTest:withEvent:返回nil；</p>
<p>点击的范围在E内，即E的pointInside:withEvent:返回YES，由于E没有子视图（也可以理解成对E的子视图进行hit-test时返回了nil），因此，E的hitTest:withEvent:会将E返回，再往回回溯，就是C的hitTest:withEvent:返回E—&gt;&gt;A的hitTest:withEvent:返回E。</p>
<p>至此，本次点击事件的第一响应者就通过响应者链的事件分发逻辑成功的找到了。</p>
<p>不难看出，这个处理流程有点类似二分搜索的思想，这样能以最快的速度，最精确地定位出能响应触摸事件的UIView。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>如果最终hit-test没有找到第一响应者，或者第一响应者没有处理该事件，则该事件会沿着响应者链向上回溯，如果UIWindow实例和UIApplication实例都不能处理该事件，则该事件会被丢弃；</p>
</li>
<li><p>hitTest:withEvent:方法将会忽略隐藏(hidden=YES)的视图，禁止用户操作(userInteractionEnabled=YES)的视图，以及alpha级别小于0.01(alpha&lt;0.01)的视图。如果一个子视图的区域超过父视图的bound区域(父视图的clipsToBounds 属性为NO，这样超过父视图bound区域的子视图内容也会显示)，那么正常情况下对子视图在父视图之外区域的触摸操作不会被识别,因为父视图的pointInside:withEvent:方法会返回NO,这样就不会继续向下遍历子视图了。当然，也可以重写pointInside:withEvent:方法来处理这种情况。</p>
</li>
<li><p>我们可以重写hitTest:withEvent:来达到某些特定的目的，当然实际应用中很少用到这些。</p>
</li>
</ul>
<hr>
<p>参考<a href="https://developer.apple.com/library/ios/#documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1" target="_blank" rel="noopener">Event Handling Guide for iOS</a>。  </p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[第一个Scrapy爬虫(二)]]></title>
      <url>http://yoursite.com/2016/05/18/%E7%AC%AC%E4%B8%80%E4%B8%AAScrapy%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><pre><code>scrapy startproject tutorial</code></pre><p>  如果没有报错，则创建成功</p>
<p>  在Mac下如果报这个错误：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/usr/local/bin/scrapy"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> <span class="keyword">execute</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/scrapy/__init__.py"</span>, line <span class="number">34</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> Spider</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/scrapy/spiders/__init__.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/scrapy/http/__init__.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">from</span> scrapy.http.request.rpc <span class="keyword">import</span> XmlRpcRequest</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/scrapy/http/request/rpc.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    <span class="keyword">from</span> six.moves <span class="keyword">import</span> xmlrpc_client <span class="keyword">as</span> xmlrpclib</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> <span class="keyword">name</span> xmlrpc_client</span><br></pre></td></tr></table></figure>


<p>  尝试</p>
<pre><code>export PYTHONPATH=/Library/Python/2.7/site-packages:$PYTHONPATH</code></pre><p>  或</p>
<pre><code>echo &quot;export PYTHONPATH=/Library/Python/2.7/site-packages:$PYTHONPATH&quot; &gt;&gt; ~/.bashrc</code></pre><p>  然后重新创建工程</p>
<p> 该命令将会创建包含下列内容的 tutorial 目录: </p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tutorial/</span><br><span class="line">   scrapy.cfg</span><br><span class="line">   tutorial/</span><br><span class="line">       __init__.py</span><br><span class="line">       items.py</span><br><span class="line">       pipelines.py</span><br><span class="line">       settings.py</span><br><span class="line">       spiders/</span><br><span class="line">           __init__.py</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure>


<p> 这些文件分别是:</p>
<ul>
<li>scrapy.cfg: 项目的配置文件</li>
<li>tutorial/: 该项目的python模块。之后您将在此加入代码。</li>
<li>tutorial/items.py: 项目中的item文件.</li>
<li>tutorial/pipelines.py: 项目中的pipelines文件.</li>
<li>tutorial/settings.py: 项目的设置文件.</li>
<li>tutorial/spiders/: 放置spider代码的目录.</li>
</ul>
<h2 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h2><p>在tutorial/spiders下创建dmoz_spider.py，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spider <span class="keyword">import</span> Spider</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DmozSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">  name = <span class="string">"dmoz"</span></span><br><span class="line">  allowed_domains = [<span class="string">"dmoz.org"</span>]</span><br><span class="line">  start_urls = [</span><br><span class="line">    <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Books/"</span>,</span><br><span class="line">    <span class="string">"http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/"</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    filename = response.url.split(<span class="string">"/"</span>)[<span class="number">-2</span>]</span><br><span class="line">    open(filename, <span class="string">'wb'</span>).write(response.body)</span><br></pre></td></tr></table></figure>

<p>上面的class中，参数说明如下：</p>
<ul>
<li>name是Scrapy 识别的爬虫名字，一定要唯一。</li>
<li>allowed_domains 是域名白名单</li>
<li>start_urls 即种子url （如果没有定义其他Rule的话，也就是只抓取这几页）</li>
<li>parse()是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。</li>
</ul>
<h3 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h3><p>切换到tutorial目录，执行：</p>
<pre><code>scrapy crawl dmoz</code></pre><p>然后，发现目录下多了 Books 和 Resources 2个文件。</p>
<p>在执行上面的shell命令时，scrapy会创建一个scrapy.http.Request对象，将start_urls传递给它，抓取完毕后，回调parse函数。</p>
<h3 id="刚才发生了什么？"><a href="#刚才发生了什么？" class="headerlink" title="刚才发生了什么？"></a>刚才发生了什么？</h3><p>Scrapy为Spider的 start_urls 属性中的每个URL创建了 scrapy.Request 对象，并将 parse 方法作为回调函数(callback)赋值给了Request。</p>
<p>Request对象经过调度，执行生成 scrapy.http.Response 对象并送回给spider parse() 方法。</p>
<hr>
<p> 参考<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/intro/tutorial.html" target="_blank" rel="noopener">Scrapy入门教程</a>。</p>
]]></content>
      
        <categories>
            
            <category> 爬虫系列 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac安装Scrapy(一)]]></title>
      <url>http://yoursite.com/2016/05/17/Mac%E5%AE%89%E8%A3%85Scrapy/</url>
      <content type="html"><![CDATA[<p>Scrapy是一个非常好的抓取框架，它提供了一些开箱可用的基础组件，还能够根据需要进行自定义。</p>
<p>下面就Mac下安装Scrapy的步骤及遇到的错误进行总结：</p>
<h2 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h2><p>打开终端执行命令：</p>
<pre><code>sudo easy_install pip</code></pre><p>pip 和 easy_install 都是 Python 的框架管理命令，pip 是对 easy_install的升级。</p>
<p>然后终端执行命令安装 Scrapy：</p>
<pre><code>sudo pip install Scrapy</code></pre><p>如果执行成功，那么 Scrapy 就安装成功了。</p>
<h3 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> Found existing installation: six 1.4.1</span><br><span class="line">    DEPRECATION: Uninstalling a distutils installed project (six) has been deprecated and will be removed <span class="keyword">in</span> a future <span class="keyword">version</span>. This is due to the <span class="keyword">fact</span> that uninstalling a distutils project will only partially uninstall the project.</span><br><span class="line">    Uninstalling six-1.4.1:</span><br><span class="line">Exception:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/basecommand.py"</span>, <span class="keyword">line</span> 215, <span class="keyword">in</span> main</span><br><span class="line">    status = self.<span class="keyword">run</span>(options, <span class="keyword">args</span>)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/commands/install.py"</span>, <span class="keyword">line</span> 317, <span class="keyword">in</span> <span class="keyword">run</span></span><br><span class="line">    prefix=options.prefix_path,</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/req/req_set.py"</span>, <span class="keyword">line</span> 736, <span class="keyword">in</span> install</span><br><span class="line">    requirement.uninstall(auto_confirm=True)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/req/req_install.py"</span>, <span class="keyword">line</span> 742, <span class="keyword">in</span> uninstall</span><br><span class="line">    paths_to_remove.remove(auto_confirm)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/req/req_uninstall.py"</span>, <span class="keyword">line</span> 115, <span class="keyword">in</span> remove</span><br><span class="line">    renames(path, new_path)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/Library/Python/2.7/site-packages/pip-8.1.2-py2.7.egg/pip/utils/__init__.py"</span>, <span class="keyword">line</span> 267, <span class="keyword">in</span> renames</span><br><span class="line">    shutil.<span class="keyword">move</span>(old, new)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py"</span>, <span class="keyword">line</span> 302, <span class="keyword">in</span> <span class="keyword">move</span></span><br><span class="line">    copy2(src, real_dst)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py"</span>, <span class="keyword">line</span> 131, <span class="keyword">in</span> copy2</span><br><span class="line">    copystat(src, dst)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py"</span>, <span class="keyword">line</span> 103, <span class="keyword">in</span> copystat</span><br><span class="line">    os.chflags(dst, <span class="keyword">st</span>.st_flags)</span><br><span class="line">OSError: [Errno 1] Operation not permitted: '/tmp/pip-ZqW0ai-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info'</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<pre><code>sudo pip install --ignore-installed six</code></pre><h3 id="错误2："><a href="#错误2：" class="headerlink" title="错误2："></a>错误2：</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">In</span> file included <span class="keyword">from</span> src/lxml/lxml.etree.c:<span class="number">320</span>:</span><br><span class="line">    src/lxml/includes/etree_defs.h:<span class="number">14</span>:<span class="number">10</span>: fatal error: <span class="string">'libxml/xmlversion.h'</span> file <span class="built_in">not</span> found</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libxml/xmlversion.h"</span></span></span><br><span class="line">             ^</span><br><span class="line">    <span class="number">1</span> error generated.</span><br><span class="line">    <span class="built_in">Compile</span> failed: command <span class="string">'cc'</span> failed <span class="keyword">with</span> <span class="keyword">exit</span> status <span class="number">1</span></span><br><span class="line">    creating tmp</span><br><span class="line">    cc -I/usr/include/libxml2 -I/usr/include/libxml2 -c /tmp/xmlXPathInitmCebQ0.c -o tmp/xmlXPathInitmCebQ0.o</span><br><span class="line">    /tmp/xmlXPathInitmCebQ0.c:<span class="number">1</span>:<span class="number">10</span>: fatal error: <span class="string">'libxml/xpath.h'</span> file <span class="built_in">not</span> found</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libxml/xpath.h"</span></span></span><br><span class="line">             ^</span><br><span class="line">    <span class="number">1</span> error generated.</span><br><span class="line">    *********************************************************************************</span><br><span class="line">    Could <span class="built_in">not</span> <span class="built_in">find</span> function xmlCheckVersion <span class="built_in">in</span> library libxml2. Is libxml2 installed?</span><br><span class="line">    Perhaps <span class="keyword">try</span>: xcode-<span class="built_in">select</span> --install</span><br><span class="line">    *********************************************************************************</span><br><span class="line">    error: command <span class="string">'cc'</span> failed <span class="keyword">with</span> <span class="keyword">exit</span> status <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    ----------------------------------------</span><br><span class="line">Command <span class="string">"/usr/bin/python -u -c "</span>import setuptools, tokenize;<span class="variable">__file__</span>=<span class="string">'/private/tmp/pip-build-yo_o0i/lxml/setup.py'</span>;<span class="built_in">exec</span>(<span class="built_in">compile</span>(getattr(tokenize, <span class="string">'open'</span>, open)(<span class="variable">__file__</span>).read().replace(<span class="string">'\r\n'</span>, <span class="string">'\n'</span>), <span class="variable">__file__</span>, <span class="string">'exec'</span>))<span class="string">" install --record /tmp/pip-2FEcHQ-record/install-record.txt --single-version-externally-managed --compile"</span> failed <span class="keyword">with</span> error code <span class="number">1</span> <span class="built_in">in</span> /<span class="keyword">private</span>/tmp/pip-build-yo_o0i/lxml/</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<pre><code>xcode-select --install</code></pre>]]></content>
      
        <categories>
            
            <category> 爬虫系列 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[三种类型的Block]]></title>
      <url>http://yoursite.com/2016/05/10/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84Block/</url>
      <content type="html"><![CDATA[<h1 id="Block作为属性"><a href="#Block作为属性" class="headerlink" title="Block作为属性"></a>Block作为属性</h1><p>把block作为对象的copy属性,定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Animal </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic,copy) void(^eat)(int);</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Person</span><br><span class="line">- (void)hungry</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">_eat</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> *a = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">[a setEat:^(int count) &#123;</span></span><br><span class="line"><span class="comment">        // TODO:</span></span><br><span class="line"><span class="comment"> &#125;]</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Bloc作为函数参数"><a href="#Bloc作为函数参数" class="headerlink" title="Bloc作为函数参数"></a>Bloc作为函数参数</h1><p>定义：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="string">Animal :</span> NSObject</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">sleep:</span>(<span class="keyword">void</span>(^)())block;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> *a = <span class="comment">[<span class="comment">[Animal alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[a sleep:^&#123;</span></span><br><span class="line"><span class="comment">        // TODO:</span></span><br><span class="line"><span class="comment">&#125;]</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Block作为函数返回值"><a href="#Block作为函数返回值" class="headerlink" title="Block作为函数返回值"></a>Block作为函数返回值</h1><p>定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">Animal </span>: NSObject</span><br><span class="line">- (void (^)(int))run;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Animal</span><br><span class="line">- (void (^)(int))run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> ^(int b)&#123;</span><br><span class="line">        <span class="selector-tag">NSLog</span>(@<span class="string">"run %d米"</span>,b);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="function"><span class="keyword">func</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Animal *a = [[Animal alloc] init]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    a.<span class="built_in">run</span>(<span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[objective-c中的缓存-NSCache]]></title>
      <url>http://yoursite.com/2016/05/09/objective-c%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98-nscache/</url>
      <content type="html"><![CDATA[<p>NSCache是系统提供的一种类似于集合（NSMutableDictionary）的缓存，它与集合的不同如下：</p>
<ol>
<li><p>NSCache具有自动删除的功能，以减少系统占用的内存；</p>
</li>
<li><p>NSCache是线程安全的，不需要加线程锁；</p>
</li>
<li><p>键对象不会像 NSMutableDictionary 中那样被复制。（NSCache的Key只是对对象的strong引用，对象不需要实现NSCopying协议，NSCache也不会像NSDictionary一样复制对象。</p>
</li>
</ol>
<h2 id="NSCache的属性以及方法介绍："><a href="#NSCache的属性以及方法介绍：" class="headerlink" title="NSCache的属性以及方法介绍："></a>NSCache的属性以及方法介绍：</h2><pre><code>@property NSUInteger totalCostLimit;</code></pre><p>设置缓存占用的内存大小，并不是一个严格的限制，当总数超过了totalCostLimit设定的值，系统会清除一部分缓存，直至总消耗低于totalCostLimit的值。</p>
<pre><code>@property NSUInteger countLimit;</code></pre><p>设置缓存对象的大小，这也不是一个严格的限制。</p>
<pre><code>- (id)objectForKey:(id)key;</code></pre><p>获取缓存对象，基于key-value对</p>
<pre><code>- (void)setObject:(id)obj forKey:(id)key; // 0 cost</code></pre><p>存储缓存对象，考虑缓存的限制属性；</p>
<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g;</code></pre><p>存储缓存对象，cost是提前知道该缓存对象占用的字节数，也会考虑缓存的限制属性，建议直接使用  - (void)setObject:(id)obj forKey:(id)key;cost值只在比较容易获取到的时候才指定，若要通过复杂的计算来获取cost值，那使用缓存的意义就不大了。</p>
<p>NSCacheDelegate代理</p>
<p>代理属性声明如下：</p>
<pre><code>@property (assign) id&lt;NSCacheDelegate&gt;delegate;</code></pre><p>实现了NSCacheDelegate代理的对象，在缓存对象即将被清理的时候，系统回调代理方法如下：</p>
<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj;</code></pre><p>第一个参数是当前缓存（NSCache），不要修改该对象；</p>
<p>第二个参数是当前将要被清理的对象，如果需要存储该对象，可以在此操作（存入Sqlite or CoreData）;</p>
<p>该代理方法的调用会在缓存对象即将被清理的时候调用，如下场景会调用：</p>
<ol>
<li><p>手动删除对象 - (void)removeObjectForKey:(id)key；</p>
</li>
<li><p>缓存对象超过了NSCache的属性限制；（countLimit 和 totalCostLimit ）</p>
</li>
<li><p>App进入后台会调用；</p>
</li>
<li><p>系统发出内存警告；</p>
</li>
</ol>
<h2 id="NSDiscardableContent协议"><a href="#NSDiscardableContent协议" class="headerlink" title="NSDiscardableContent协议"></a>NSDiscardableContent协议</h2><p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>
<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。这点类似于MRC&amp;ARC，对象内存回收机制。</p>
<pre><code>- (void)discardContentIfPossible</code></pre><p>当counter等于0的时候，为了丢弃这些对象，会调用这个方法。</p>
<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。</p>
<pre><code>- (BOOL)beginContentAccess    (counter++)</code></pre><p>调用该方法，对象的counter会加1；</p>
<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>
<pre><code>- (void)endContentAccess  （counter--）</code></pre><p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>
<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(默认该属性为YES)，其声明如下：</p>
<pre><code>@property BOOL evictsObjectsWithDiscardedContent</code></pre><p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在AFNetworking的UIKit中，使用了NSCache来提供异步图片下载的缓存。UIImageView+AFNetworking.h文件中，声明了一个AFImageCache协议，提供读取和放入缓存的方法。UIImageView+AFNetworking.m文件中，声明了一个继承自NSCache的类AFImageCache，实现了AFImageCache协议，并且实现了协议中的两种文件操作方法，实现代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">AFImageCache</span> : <span class="title">NSCache</span> &lt;<span class="title">AFImageCache</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSString</span> * AFImageCacheKeyFromURLRequest(<span class="built_in">NSURLRequest</span> *request) &#123;</span><br><span class="line">    <span class="keyword">return</span> [[request URL] absoluteString];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageCache</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)cachedImageForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="keyword">switch</span> ([request cachePolicy]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSURLRequestReloadIgnoringCacheData</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> objectForKey:AFImageCacheKeyFromURLRequest(request)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cacheImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">        forRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (image &amp;&amp; request) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setObject:image forKey:AFImageCacheKeyFromURLRequest(request)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用absolute URL作为key，将图片缓存起来。在UIImageView类中，通过单例方式，获取AFImageCache的实例。代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span> &lt;AFImageCache&gt;)sharedImageCache &#123;</span><br><span class="line">    <span class="keyword">static</span> AFImageCache *_af_defaultImageCache = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _af_defaultImageCache = [[AFImageCache alloc] init];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * __unused notification) &#123;</span><br><span class="line">            [_af_defaultImageCache removeAllObjects];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wgnu"</span></span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sharedImageCache)) ?: _af_defaultImageCache;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若在其他地方下载了图片，只需调用sharedImageCache方法，获取到一个NSCache实例，将图片放入缓存，URL作为key，那么再调用UIImageView时，指定URL，就可以直接从缓存中获取图片。</p>
<p>参考<a href="http://www.jianshu.com/p/5e69e211b161" target="_blank" rel="noopener">NSCache</a>。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo常用命令]]></title>
      <url>http://yoursite.com/2016/04/10/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p>hexo n == hexo new</p>
<p>hexo p == hexo publish</p>
<p>hexo g == hexo generate</p>
<p>hexo s == hexo server</p>
<p>hexo d == hexo deploy</p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<p>hexo server -s #静态模式</p>
<p>hexo server -p 5000 #更改端口</p>
<p>hexo server -i 192.168.1.1 #自定义 IP</p>
<p>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</p>
<p>hexo g #生成静态网页</p>
<p>hexo d #开始部署</p>
<h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><p>hexo generate #使用 Hexo 生成静态文件快速而且简单</p>
<p>hexo generate –watch #监视文件变动</p>
<h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><p>两个命令的作用是相同的</p>
<p>hexo generate –deploy hexo deploy –generate<br>hexo deploy -g hexo server -g</p>
<p>原文<a href="http://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a>。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自我管理的破窗效应]]></title>
      <url>http://yoursite.com/2016/04/10/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E7%9A%84%E7%A0%B4%E7%AA%97%E6%95%88%E5%BA%94/</url>
      <content type="html"><![CDATA[<pre><code>在《程序员修炼之道——从小工到专家》这本书里，有这么一段描述：

在市区，有些建筑漂亮而整洁，而另一些却是破败不堪的“废弃船只”。为什么？犯罪和城市衰退领域的研究者发现了一种迷人的触发机制，
一种能够很快将整洁、完整和有人居住的建筑变为破败的废弃物的机制[WK82]。

破窗户。

一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感——一种职权部门不关心这座建筑的感觉。
于是又一扇窗户破了。人们开始乱扔垃圾。出现了乱涂乱画。严重的结构损坏开始了。在相对较短的一段时间里，
建筑就被损毁得超出了业主愿意修理的程度，而废弃感变成了现实。

“破窗户理论”启发了纽约和其他大城市的警察部门，他们对一些轻微的案件严加处理，以防止大案的发生。
这起了作用：管束破窗户、乱涂乱画和其他轻微违法事件减少了严重罪案的发生。</code></pre><p>不知道你有没有过类似这样的经验：</p>
<p>比如你坚持每天都跑步，风雨不断。一旦养成习惯，做这件事情感觉就是理所当然的。然后某天你病了，休息了一个星期，然后你会发现，原来不跑步也是可以的，还节省时间，不累。于是你慢慢就开始不跑了，于是跑步锻炼这个好习惯就被你丢了。后果呢？可能身材开始慢慢肥胖变形了，身体也不那么强健了，开始犯一些小毛病了。学习效率也开始下降了，要知道，运动能够提高大脑的活性，学习效率也会得到提高的。所以简单的一个破窗没有及时堵住，最后能导致一连串不良效果的出现。</p>
<p>又比如你坚持每天都写博客，记录代码片段，或者写点什么东西。一开始也是努力严格要求自己，必须每天都要写。然而总会有些原因让你无法写，比如出差、加班、旅游等等。发现博客断更了几天，于是就开始断更了得更厉害了，变成几周更新一次，几个月更新一次，慢慢博客就荒废了。博客是整理思维，总结所学的一个非常好的习惯。有坚持写博客习惯的人，往往思路清晰，逻辑有条理，长期以往，思维会变得活跃并深邃。所以这个习惯的丢弃，是非常可惜的，个人的成长失去一个有效的总结提升机制。长期的习惯可能都遭不住破窗的侵袭，更何况是三分钟热度的东西。</p>
<p>又比如你的工作台一开始是很整洁的，因此你心情不错，办事效率也很高（PS：国外一个研究理论，整洁的工作台能够提高你的工作效率）。但是某个时候你放了个杯子，摆了个电话，堆了些文件……慢慢桌面上的东西越来越多，也开始慢慢变乱，你没注意收拾好，于是越来越乱。最后乱得影响你工作的心情，然后办事效率低，工作表现开始变差，然后出现一连串恶性循环，比如因为表现不好得不到领导的赏识了，升迁受阻，个人精神开始颓滞等。仅仅因为一个工作台的破窗，就可能影响到一个人的职业发展。可能有点夸张，但工作优秀的人，桌面基本都是一直保持得很整洁的。</p>
<p>再举一个最简单的例子。你打算每个月存5000元，一开始也确实将5000元存进银行或者各种地方了。然后你看到某个东西你很喜欢，也不贵，就剁手买买买了。当5000元变成4xxx时，破窗就开始出现了，你会继续被各种消费欲望驱使，最后全花光了。而如果一开始你忍住不剁手的话，也许5000元也许就可以全存下了。一百元不找散的话，是不是可以在钱包里呆得比较久呢？又或者那一百元是崭新的新版土豪金，又是不是会呆得更久呢？破窗这个东西很神奇。</p>
<p>优秀往往来源于好习惯，而习惯优秀则能走向卓越。偶尔看到一些对学神的采访，问为什么学习能这么厉害。学神无非就说，坚持早读啊，坚持晚上学习到多晚等等。看似简单，但是要你每天都做那可就不简单了。学渣坚持早读晚修，努力学习，也许一年就可以变学民了。再坚持个三年，也许就可以变学霸了。而一直坚持下去，始终不落下这个习惯，也许就能成为学神了。学神诚不欺余也。</p>
<p>所以好习惯的重要性不言而喻。好习惯是靠坚持养出来的，而注意防范自我管理中的破窗，非常重要。一个小小的懈怠，也许就能毁掉你十年的习惯。严格要求自己，不要让懒惰滋生破窗。</p>
<p>本文转自<a href="http://www.nowamagic.net/librarys/veda/detail/2816" target="_blank" rel="noopener">自我管理中的破窗效应</a>。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim命令合集]]></title>
      <url>http://yoursite.com/2015/09/24/Vim%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<h1 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h1><pre><code>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</code></pre><h1 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h1><p>在命令行窗口中输入以下命令即可</p>
<pre><code>vim 直接启动vim

vim filename 打开vim并创建名为filename的文件</code></pre><h1 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h1><p>打开单个文件</p>
<pre><code>vim file</code></pre><p>同时打开多个文件</p>
<pre><code>vim file1 file2 file3 ...</code></pre><p>在vim窗口中打开一个新文件</p>
<pre><code>:open file</code></pre><p>在新窗口中打开文件</p>
<pre><code>:split file</code></pre><p>切换到下一个文件</p>
<pre><code>:bn</code></pre><p>切换到上一个文件</p>
<pre><code>:bp</code></pre><p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p>
<pre><code>:args</code></pre><p>打开远程文件，比如ftp或者share folder</p>
<pre><code>:e ftp://192.168.10.76/abc.txt
:e \\qadrive\test\1.txt</code></pre><h1 id="Vim的模式"><a href="#Vim的模式" class="headerlink" title="Vim的模式"></a>Vim的模式</h1><ul>
<li>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空</li>
<li>插入模式（按i键进入） 左下角显示–INSERT–</li>
<li>可视模式（不知道如何进入） 左下角显示–VISUAL–</li>
</ul>
<h1 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h1><pre><code>% 括号匹配</code></pre><h1 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h1><pre><code>i 在当前位置生前插入

I 在当前行首插入

a 在当前位置后插入

A 在当前行尾插入

o 在当前行之后插入一行

O 在当前行之前插入一行</code></pre><h1 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h1><pre><code>/text　　查找text，按n健查找下一个，按N健查找前一个。

?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。

vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$

:set ignorecase　　忽略大小写的查找

:set noignorecase　　不忽略大小写的查找

查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。

:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。

:set nohlsearch　　关闭高亮搜索显示

:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。

:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。

:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</code></pre><h1 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h1><pre><code>ra 将当前字符替换为a，当期字符即光标所在字符。

s/old/new/ 用old替换new，替换当前行的第一个匹配

s/old/new/g 用old替换new，替换当前行的所有匹配

%s/old/new/ 用old替换new，替换所有行的第一个匹配

%s/old/new/g 用old替换new，替换整个文件的所有匹配

:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。

ddp 交换光标所在行和其下紧邻的一行。</code></pre><h1 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h1><pre><code>h 左移一个字符
l 右移一个字符，这个命令很少用，一般用w代替。
k 上移一个字符
j 下移一个字符</code></pre><p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<esc>，这里的Esc是必须的，否则命令不生效。</esc></p>
<pre><code>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。

b 向后移动一个单词 2b 向后移动2个单词

e，同w，只不过是光标停在单词尾部

ge，同b，光标停在单词尾部。

^ 移动到本行第一个非空白字符上。

0（数字0）移动到本行第一个字符上，

&lt;HOME&gt; 移动到本行第一个字符。同0健。

$ 移动到行尾 3$ 移动到下面3行的行尾

gg 移动到文件头。 = [[

G（shift + g） 移动到文件尾。 = ]]

f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。

F 同f，反向查找。

跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。

Ctrl + e 向下滚动一行

Ctrl + y 向上滚动一行

Ctrl + d 向下滚动半屏

Ctrl + u 向上滚动半屏

Ctrl + f 向下滚动一屏

Ctrl + b 向上滚动一屏</code></pre><h1 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h1><pre><code>u 撤销（Undo）
U 撤销对整行的操作
Ctrl + r 重做（Redo），即撤销的撤销。</code></pre><h1 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h1><pre><code>x 删除当前字符

3x 删除当前光标开始向后三个字符

X 删除当前字符的前一个字符。X=dh

dl 删除当前字符， dl=x

dh 删除前一个字符

dd 删除当前行

dj 删除上一行

dk 删除下一行

10d 删除当前行开始的10行。

D 删除当前字符至行尾。D=d$

d$ 删除当前字符之后的所有字符（本行）

kdgg 删除当前行之前所有行（不包括当前行）

jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）

:1,10d 删除1-10行

:11,$d 删除11行及以后所有的行

:1,$d 删除所有行

J(shift + j)　　删除两行之间的空行，实际上是合并两行。

拷贝和粘贴

yy 拷贝当前行

nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。

p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。

shift+p 在当前行前粘贴

:1,10 co 20 将1-10行插入到第20行之后。

:1,$ co $ 将整个文件复制一份并添加到文件尾部。

正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制

ddp交换当前行和其下一行

xp交换当前字符和其后一个字符</code></pre><h1 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h1><pre><code>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切

ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴

:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。

:1, 10 m 20 将第1-10行移动到第20行之后。</code></pre><h1 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h1><pre><code>:wq 保存并退出

ZZ 保存并退出

:q! 强制退出并忽略所有更改

:e! 放弃所有修改，并打开原来文件。</code></pre><h1 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h1><pre><code>:split或new 打开一个新窗口，光标停在顶层的窗口上

:split file或:new file 用新窗口打开文件

split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。

Ctrl+ww 移动到下一个窗口

Ctrl+wj 移动到下方的窗口

Ctrl+wk 移动到上方的窗口</code></pre><h1 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h1><pre><code>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。

:q 如果是最后一个被关闭的窗口，那么将退出vim。

ZZ 保存并退出。

关闭所有窗口，只保留当前窗口

:only</code></pre><h1 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h1><pre><code>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。

执行shell命令

:!command

:!ls 列出当前目录下文件

:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。

:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。

:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</code></pre><h1 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h1><pre><code>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#

3,5 s/^/#/g 注释第3-5行

3,5 s/^#//g 解除3-5行的注释

1,$ s/^/#/g 注释整个文档。

:%s/^/#/g 注释整个文档，此法更快。</code></pre><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><pre><code>:help or F1 显示整个帮助
:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。
:help &apos;number&apos; Vim选项的帮助用单引号括起
:help &lt;Esc&gt; 特殊键的帮助用&lt;&gt;扩起
:help -t Vim启动参数的帮助用-
：help i_&lt;Esc&gt; 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式
帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</code></pre><h1 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h1><pre><code>. 重复前一次命令

:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看

:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。

:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。

Vim教程
在Unix系统上
$ vimtutor
在Windows系统上
:help tutor

:syntax 列出已经定义的语法项
:syntax clear 清除已定义的语法规则
:syntax case match 大小写敏感，int和Int将视为不同的语法元素
:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</code></pre><hr>
<p> 本文转自<a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">WWDC 2015: AUTO LAYOUT IMPROVEMENTS</a>。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[WWDC 2015: AUTO LAYOUT在iOS 9上的改进]]></title>
      <url>http://yoursite.com/2015/09/23/WWDC-2015-AUTO-LAYOUT%E5%9C%A8iOS-9%E4%B8%8A%E7%9A%84%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<p>自从AUTO LAYOUT在iOS 6中引入以来,我一直深深的为之着迷，特别是通过直接在代码中使用它,而不是使用故事板。但它在代码中使用非常冗长。我写了一些类,使代码更加紧凑。但我不满意我的解决方案。所以我计划在WWDC期间去一个实验室,咨询一个苹果AUTO LAYOUT工程师对这个问题的看法。但是事实证明我不需要!苹果解决了大部分我在AUTO LAYOUT中遇到的问题在iOS 9的API中!在这篇文章中我想突出的新API更容易使用自动布局在代码和故事板! 在这片文章中，我将分别用代码和Storyboard展示用新的API使用AUTO LAYOUT是如何简单易用。</p>
<h2 id="什么是AUTO-LAYOUT"><a href="#什么是AUTO-LAYOUT" class="headerlink" title="什么是AUTO LAYOUT"></a>什么是AUTO LAYOUT</h2><p>对于那些AUTO LAYOUT的新手，我想快速的过一下这东西到底是什么。AUTO LAYOUT是一个机制,用它可以很容易地支持不同的屏幕尺寸。<br>AUTO LAYOUT的核心是极其简单的。它使用“约束”来确定视图在屏幕上的x,y,宽度和高度属性。约束是描述一个视图的位置和大小的规则。一个视图需要多个约束来正确的定位和限制大小。约束和所代表它的类youtConstraint仅仅是遵循这个公式:</p>
<pre><code>view1.attribute1 = view2.attribute2 x A + B</code></pre><p>这是AUTO LAYOUT的核心,所有的约束都遵循这种模式。使用一系列遵循这种模式的约束你可以布局一切，它将在巧妙的缩放来适应不同的屏幕尺寸。<br>例如:</p>
<pre><code>label.Top = container.Top x 1 + 20(列出了一个标签的y值低于容器的顶部边缘视图20像素点)
label.Width = container.Width x 0.5 + 0 (一个标签的宽度设置为一半的容器的宽度)</code></pre><h2 id="为什么使用AUTO-LAYOUT？"><a href="#为什么使用AUTO-LAYOUT？" class="headerlink" title="为什么使用AUTO LAYOUT？"></a>为什么使用AUTO LAYOUT？</h2><p>在很长的一段时间内,iOS应用程序并没有在关心屏幕大小适配。iPhone 3g,4和4s基本上都是分辨率为320×480的逻辑点。随着视网膜屏幕的引入并没有改变,因为作为一名开发人员你仍然可以假装屏幕是320×480,而系统会为你转换为640×960。当然你也有iPad,但你不必为之做更多的工作,因为你将为iPad设计一个特定的用户界面,这将是特定的屏幕分辨率1024×768。</p>
<h2 id="支持不同的分辨率"><a href="#支持不同的分辨率" class="headerlink" title="支持不同的分辨率"></a>支持不同的分辨率</h2><p>随着iPhone 4s到来的iOS 6.0,给我们介绍了自动布局。我们不觉得有必要使用它,但在它的目的很明显:使它容易支持iPhone更大的屏幕!在那一刻唯一的真正好处来自屏幕的旋转，从竖屏到横屏,这实际上也是一个分辨率的变化。</p>
<h2 id="iPad的多任务模式"><a href="#iPad的多任务模式" class="headerlink" title="iPad的多任务模式"></a>iPad的多任务模式</h2><p>随着iOS 9的到来，AUTO LAYOUT变得如此重要的一个原因是：在iPad上支持多任务！现在你可以观看并排的两个应用程序在同一时间，这意味着应用程序要能够缩放自己的尺寸为四分之一屏幕或者半个屏幕。用户决定显示每个应用程序的大小。使用AUTO LAYOUT可以很容易适应这些变化。</p>
<h2 id="STACKING-VIEWS"><a href="#STACKING-VIEWS" class="headerlink" title="STACKING VIEWS"></a>STACKING VIEWS</h2><p>Before iOS 9, we had to add many different constraints to all different views within a single screen to position them correctly and let them handle screen size changes accordingly. This was easy, but a little hard to manage. There were two ways to do it:</p>
<p>在iOS 9之前，我们不得不在一个屏幕上对所有子视图添加许多不同的约束来使它们适应屏幕大小的变化。这是一件简单的事情，但是难于管理。有两种方式可以实现：</p>
<ul>
<li>使用 storyboard</li>
<li>使用代码</li>
</ul>
<h3 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard"></a>Storyboard</h3><p><img src="http://blog.trifork.com/wp-content/uploads/2015/06/Safari-developer.apple_.com-Screen-Shot-21-June-2015-at-1626.png" alt="storyboard"></p>
<p>使用故事板可以单击并拖动来创建约束，你最终将得到的大量的蓝线,这代表了约束。现在你想要插入另一个标签,在“车库乐队”和“苹果”之间。你该怎么做?你删除一些约束连接现有的标签,插入你的新标签和你现有的两个标签连接到你的新标签。这足以说明约束维护的复杂性。</p>
<h3 id="用代码实现约束"><a href="#用代码实现约束" class="headerlink" title="用代码实现约束"></a>用代码实现约束</h3><p>用代码实现的话也存在同样的问题，这里没有蓝线，取而代之的是：</p>
<pre><code>view.addConstraints(NSLayoutConstraint.constraintsWithVisualFormat(
&quot;V:|[titleLabel]-padding-[descriptionLabel]-padding-[imageView]&quot;, 
options: nil,
 metrics: [&quot;padding&quot;: 10],
  views: [
          &quot;titleLabel&quot;: titleLabel,
          &quot;descriptionLabel&quot;: descriptionLabel,
          &quot;imageView&quot;: imageView])
)
view.addConstraint(NSLayoutConstraint(
   item: titleLabel,
   attribute: .Leading,
   relatedBy: .Equal,
   toItem: self,
   attribute: .Leading,
   multiplier: 1,
   constant: 10)
)</code></pre><p>这仍然不是最佳的管理方案。</p>
<h3 id="UIStackView"><a href="#UIStackView" class="headerlink" title="UIStackView"></a>UIStackView</h3><p>随着iOS 9的一声炮响，UIStackView应运而生！你可以把一组子视图放入UIStackView，并将它们垂直或水平布局，这不费吹灰之力。不再需要为每个子视图添加约束。这一切UIStackView都已经为你做好。</p>
<p>在上边儿的例子中你只需要标示那里需要使用stack view。你只需找出子视图需要堆积的位置。几乎所有你能想到的UI都可以都可以通过嵌套stack views的方式建立视图。苹果强烈建议我们为每一个布局使用stack views，只有那些用stack views实在无法实现的才需要用单独的约束。</p>
<p>使用stack view的示例：</p>
<pre><code>let stackView = UIStackView(arrangedSubviews: [titleLabel, descriptionLabel, imageView])
stackView.distribution = .Fill
stackView.alignment = .Leading
stackView.axis = .Vertical
stackView.spacing = 10</code></pre><p>就是这样!在titleLabel和descriptionLabel之间添加一个label就像将其添加到数组的“arrangedSubviews”一样简单!<br>一个额外的好处:你可以很容易地通过动画动画隐藏/显示视图通过修改UIView的隐藏属性,而该属性通常不能做成动画。</p>
<p><img src="https://raw.githubusercontent.com/tomvanzummeren/TZStackView/master/assets/TZStackView-hide-animation.gif" alt="stackview"></p>
<p>所有需要的是修改动画的隐藏属性,如下:</p>
<pre><code>UIView.animateWithDuration(0.5, animations: {
   someSubview.hidden = true
})</code></pre><h3 id="我自己实现的UIStackView"><a href="#我自己实现的UIStackView" class="headerlink" title="我自己实现的UIStackView"></a>我自己实现的UIStackView</h3><p>多么完美的UIStackView，但是它只能用在iOS 9及以上版本。但是我想用在iOS 7和iOS 8之中。UIStackView的接口看起来足够简单：用一个视图数组初始化它，配置它的一些属性如‘distribution’, ‘alignment’ 和 ‘axis’。这就是它！我想，这有多难？然而事实证明它比我想象的要难得多，但是我做到了！我完全重写了整个过程咋iOS 7和iOS 8之下。我为之自豪：TZStackView！<br><a href="https://github.com/tomvanzummeren/TZStackView" target="_blank" rel="noopener">TZStackView git地址</a></p>
<p>我将它设计为和UIStackView一模一样的接口，以便于将来某一天被替代。使用TZStackView的实现上面的例子：</p>
<pre><code>let stackView = TZStackView(arrangedSubviews: [titleLabel, descriptionLabel, imageView])
stackView.distribution = .Fill
stackView.alignment = .Leading
stackView.axis = .Vertical
stackView.spacing = 10</code></pre><h2 id="LAYOUT-GUIDES"><a href="#LAYOUT-GUIDES" class="headerlink" title="LAYOUT GUIDES"></a>LAYOUT GUIDES</h2><p>另一个新的iOS 9Auto Layout的概念是“layout guide”。是“constrain negative space”。什么意思?看个例子:<br>你有三个固定宽度的视图用来填补可用空间,你想让这些矩形之间的间距相等。</p>
<p><img src="http://blog.trifork.com/wp-content/uploads/2015/06/spacing-example.png" alt="layout guides"></p>
<p>The empty space in between the boxes is called ‘negative space’ and you want to express using constraints that you want those spaces to be equal to one another. Long story short: you can’t express that directly because constraints can only be applied on views, not on margins between those views. Before iOS 9 what you could do is add 4 transparent subviews in between those boxes, also known as ‘spacer views’ and put constraints on those. That works like a charm!</p>
<p>The problem with this approach is that it’s kind of a hack. You pollute your view hierarchy with things that are just there to position other views with no purpose of their own. This also impacts performance.</p>
<p>This brings me to layout guides, represented by the UILayoutGuide class. You can add them to your view like this:</p>
<p>视图之间的空的空间被称为“negative space”，你的目的是使用约束来使这些空间相等。长话短说:你不能直接表达,因为约束只能应用于视图,而不是那些视图之间的间距。在iOS 9之前你可以做的是添加4个透明子视图在这些视图之间,这些也被称为“间隔视图”，然后给这些视图添加约束。<br>这种方法的问题在于它是一种黑客技术。这污染了你的视图层次，它们仅仅是为了固定其他视图而没有自己的意义。这也影响了性能。<br>为此，引入了“layout guide”,由UILayoutGuide类来实现。你可以将它们添加到你的视图，像这样：</p>
<pre><code>let layoutGuide = UILayoutGuide()
view.addLayoutGuide(layoutGuide)</code></pre><p>Next, you can use the layout guide in your constraints, just as you would do using ‘spacer views’.</p>
<p>接下来，你可以在你的约束中使用layout guide，就像使用‘spacer views’。</p>
<pre><code>view.addConstraint(NSLayoutConstraint(
         item: layoutGuide1,
    attribute: .Width,
    relatedBy: .Equal,
       toItem: layoutGuide2,
    attribute: .Width,
   multiplier: 1,
     constant: 0)
 )</code></pre><p>这样做的好处是,我们不污染我们的视图层次和替换‘spacer views’用更轻量级的‘layout guides’。它们不能回应触摸或直观地呈现在屏幕上。它们只是在那里给其他视图提供约束。</p>
<h2 id="CONSTRAINTS-FLUENT-INTERFACE"><a href="#CONSTRAINTS-FLUENT-INTERFACE" class="headerlink" title="CONSTRAINTS FLUENT INTERFACE"></a>CONSTRAINTS FLUENT INTERFACE</h2><p>这也是一个功能在不久的将来会普遍使用的功能。它在WWDC的两节演讲中被提到。它简化了你创建单独约束的过程。在此重复我之前给出的一个例子:</p>
<pre><code>view.addConstraint(NSLayoutConstraint(
      item: titleLabel,
 attribute: .Leading,
 relatedBy: .Equal,
    toItem: self,
 attribute: .Leading,
multiplier: 1,
  constant: 10)
)</code></pre><p>现在你可以用下边儿的代码来达到同样的效果：</p>
<pre><code>view.leadingAnchor.constraintEqualToAnchor(titleLabel.leadingAnchor, constant: 10)    </code></pre><p>当我第一次看到这种新的写约束的方式时我非常激动。易读、易记忆更易于管理。这和UIStackView配合使用将大大简化编写自动布局代码的数量。</p>
<h2 id="RIGHT-TO-LEFT-LANGUAGE-SUPPORT"><a href="#RIGHT-TO-LEFT-LANGUAGE-SUPPORT" class="headerlink" title="RIGHT-TO-LEFT LANGUAGE SUPPORT"></a>RIGHT-TO-LEFT LANGUAGE SUPPORT</h2><p>从右到左的语言支持已经在这儿了！我不知道这是否令人着迷,但显然使用从右到左的语言,例如阿拉伯语的人更期望用户界面右对齐。</p>
<p><img src="http://blog.trifork.com/wp-content/uploads/2015/06/Safari-developer.apple_.com-Screen-Shot-21-June-2015-at-2102-169x300.png" alt="RIGHT-TO-LEFT"></p>
<p>它的实现是很简单的。他们仅仅使用了“Leading”和“Trailing”的布局属性抽象“Left”和“Right”。在iOS 9之前“Leading”和“Trailing”的布局属性已经存在,但他们相当于“Left”和“Right”。事实上,苹果公司推荐使用“Leading”和“Trailing”来替代“Left”和“Right”。这样你的应用程序支持从右到左的语言只是分分钟的事情！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Auto Layout在iOS 9上做了很多该进，总结下:</p>
<ul>
<li>stack view</li>
<li>layout guides</li>
<li>layout anchors (fluent interface)</li>
<li>right-to-left language support</li>
</ul>
<p>推荐观看<a href="https://developer.apple.com/videos/wwdc/2015/?id=218" target="_blank" rel="noopener">Mysteries of Auto Layout – part 1</a>. 来学习怎样调试Auto Layout问题, 观看<a href="https://developer.apple.com/videos/wwdc/2015/?id=219" target="_blank" rel="noopener">Mysteries of Auto Layout – part 2</a>来了解更多细节. 想了解right-to-left language support, 阅读<a href="https://developer.apple.com/videos/wwdc/2015/?id=222" target="_blank" rel="noopener">New UIKit Support for International User Interfaces</a>.</p>
<hr>
<p>本文翻译自<a href="http://blog.trifork.com/2015/06/22/wwdc-2015-auto-layout-improvements/" target="_blank" rel="noopener">WWDC 2015: AUTO LAYOUT IMPROVEMENTS</a>，转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://yoursite.com/2015/09/16/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="CocoaPods是什么？"><a href="#CocoaPods是什么？" class="headerlink" title="CocoaPods是什么？"></a>CocoaPods是什么？</h1><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库。总之，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。这个时候，你需要 CocoaPods。</p>
<p>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。</p>
<h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p>在安装CocoaPods之前，首先要在本地安装好Ruby环境。至于如何在Mac中安装好Ruby环境，请google一下，本文不再涉及。</p>
<p>假如你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在终端中输入以下命令：</p>
<p>sudo gem install cocoapods<br>但是，且慢。如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。</p>
<p>但是，是的，又但是（不过是个可喜的“但是”）。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令：</p>
<p>$ gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a><br>//等有反应之后再敲入以下命令<br>$ gem sources -a <a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a><br>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p>
<p>$ gem sources -l<br>只有在终端中出现下面文字才表明你上面的命令是成功的：</p>
<p><strong>* CURRENT SOURCES *</strong></p>
<p><a href="http://ruby.taobao.org/" target="_blank" rel="noopener">http://ruby.taobao.org/</a><br>上面所有的命令完成之时，你再次在终端中运行：</p>
<p>$ sudo gem install cocoapods<br>等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>好了，安装好CocoPods之后，接下来就是使用它。所幸，使用CocoPods和安装它一样简单，也是通过一两行命令就可以搞定。</p>
<h1 id="场景1：利用CocoaPods，在项目中导入AFNetworking类库"><a href="#场景1：利用CocoaPods，在项目中导入AFNetworking类库" class="headerlink" title="场景1：利用CocoaPods，在项目中导入AFNetworking类库"></a>场景1：利用CocoaPods，在项目中导入AFNetworking类库</h1><p>AFNetworking类库在GitHub地址是：<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">https://github.com/AFNetworking/AFNetworking</a></p>
<p>为了确定AFNetworking是否支持CocoaPods，可以用CocoaPods的搜索功能验证一下。在终端中输入：</p>
<pre><code>$ pod search AFNetworking</code></pre><p>过几秒钟之后，你会在终端中看到关于AFNetworking类库的一些信息。</p>
<p>这说明，AFNetworking是支持CocoaPods，所以我们可以利用CocoaPods将AFNetworking导入你的项目中。</p>
<p>首先，我们需要在我们的项目中加入CocoaPods的支持。先利用Xcode创建一个名字CocoaPodsDemo的项目，用于以下的教程。</p>
<p>你看到这里也许会问，CocoaPods为什么能下载AFNetworking呢，而不是下载其他类库呢？这个问题的答案是，有个文件来控制CocoaPods该下载什么。这个文件就叫做“Podfile”（注意，一定得是这个文件名，而且没有后缀）。你创建一个Podfile文件，然后在里面添加你需要下载的类库，也就是告诉CocoaPods，“某某和某某和某某某，快到碗里来！”。每个项目只需要一个Podfile文件。</p>
<p>好吧，废话少说，我们先创建这个神奇的PodFile。在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p>
<pre><code>$ vim Podfile</code></pre><p>然后在Podfile文件中输入以下文字：</p>
<pre><code>platform :ios, &apos;7.0&apos;
pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot;</code></pre><p>注意，这段文字不是凭空生成的，可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。</p>
<p>然后保存退出。vim环境下，保存退出命令是：</p>
<p>:wq<br>这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。</p>
<p>这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令：</p>
<p>$ pod install<br>因为是在你的项目中导入AFNetworking，这就是为什么这个命令需要你进入你的项目所在目录中运行。</p>
<p>运行上述命令之后，终端出现以下信息：</p>
<pre><code>EricmatoMacBook-Pro:CocoaPodsDemo ericwang$ pod install
Analyzing dependencies
Downloading dependencies
Installing AFNetworking (2.0.2)
Generating Pods project
Integrating client project

[!] From now on use `CocoaPodsDemo.xcworkspace`.</code></pre><p>注意最后一句话，意思是：以后打开项目就用 CocoaPodsDemo.xcworkspace 打开，而不是之前的.xcodeproj文件。</p>
<p>你也许会郁闷，为什么会出现.xcodeproj文件呢。这正是你刚刚运行$ pod install命令产生的新文件。除了这个文件，你会发现还多了另外一个文件“Podfile.lock”和一个文件夹“Pods”。 点击 CocoaPodsDemo.xcworkspace 打开之后工程之后，你会惊喜地发现，AFNetwoking已经成功导入项目了。<br>现在，你就可以开始使用AFNetworking.h啦。可以稍微测试一下，在你的项目任意代码文件中输入：</p>
<pre><code>#import &quot;AFNetworking.h&quot;</code></pre><p>然后编译，看看是否出错。</p>
<p>至此，CocoPods的第一个应用场景讲述完毕。过程总结一下就是：</p>
<p>先在项目中创建Podfile，Podfile的内容是你想导入的类库。一般类库的原作者会告诉你导入该类库应该如何写Podfile；<br>运行命令：`$ pod install.</p>
<h2 id="场景2：如何正确编译运行一个包含CocoPods类库的项目"><a href="#场景2：如何正确编译运行一个包含CocoPods类库的项目" class="headerlink" title="场景2：如何正确编译运行一个包含CocoPods类库的项目"></a>场景2：如何正确编译运行一个包含CocoPods类库的项目</h2><p>你也许曾经遇到过（特别是新手iOS开发者）这种情况，好不容易在GitHub上找到一份代码符合自己想需求，兴冲冲下载下来，一编译，傻眼了，发现有各种各样错误。一看，原来是缺失了各种其他第三方类库。这时候莫慌，你再仔细一看，会发现你下载的代码包含了Podfile。没错，这意味着你可以用CocoaPods很方便下载所需要的类库。</p>
<p>下面，以代码 UAAppReviewManager 为例来说明如何正确编译运行一个包含CocoPods类库的项目。</p>
<p>UAAppReviewManager是一个能够让你方便地将提醒用户评分的功能加入你的应用中。当你去UAAppReviewManager的GitHub地址下载这份代码之后，打开Example工程（UAAppReviewManagerExample），编译，你会发现Xcode报告一大堆错误，基本都是说你编译的这份代码找不到某某头文件，这就意味着你要成功编译UAAppReviewManager的Example代码，必须先导入一些第三方类库。同时你会发现在UAAppReviewManagerExample文件夹下面有三个跟CocosPods相关的文件（文件夹）：Podfile，Podfile.lock和Pods，这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）：</p>
<pre><code>$ pod update</code></pre><p>过几秒（也许需要十几秒，取决于你的网络状况）之后，终端出现：</p>
<pre><code>Analyzing dependencies
Fetching podspec for `UAAppReviewManager` from `../`
Downloading dependencies
Installing UAAppReviewManager (0.1.6)
Generating Pods project
Integrating client project

[!] From now on use `UAAppReviewManagerExample.xcworkspace`.</code></pre><p>这时候，再回到UAAppReviewManagerExample文件夹看一看，会看到多了一个文件UAAppReviewManagerExample.xcworkspace：</p>
<p>根据终端的信息提示，你以后就需用新产生的UAAppReviewManagerExample.xcworkspace来运行这个Example代码了。</p>
<p>打开UAAppReviewManagerExample.xcworkspace，编译运行，成功！</p>
<p>注意，这里有个小问题，如果刚刚你不是输入$ pod update，而是输入$ pod install，会发现类库导入不成功，并且终端出现下面提示：</p>
<pre><code>[!] Required version (UAAppReviewManager (from `../`)) not found for `UAAppReviewManager`.
Available versions: 0.1.6</code></pre><p>这里的意思大概是Podfile文件过期，类库有升级，但是Podfile没有更改。$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是 $ pod update会更新所有的类库，获取最新版本的类库。而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p>
<p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 $ pod update。</p>
<h2 id="场景3：使用CocoaPods开发并打包静态库"><a href="#场景3：使用CocoaPods开发并打包静态库" class="headerlink" title="场景3：使用CocoaPods开发并打包静态库"></a>场景3：使用CocoaPods开发并打包静态库</h2><p>通常我们用pod来管理第三方开源类库，但我们也极有可能会开发一个用pod管理依赖关系的静态类库给其他人使用，而又不愿意公开源代码，比如一些SDK，那么就需要打包成.a文件。本文将以一个依赖于ASIHTTPRequest的静态类库，来演示如何创建使用了CocoaPods的静态类库以及打包的过程。</p>
<h3 id="开发静态库（Static-Library）"><a href="#开发静态库（Static-Library）" class="headerlink" title="开发静态库（Static Library）"></a>开发静态库（Static Library）</h3><p>创建静态库，有2种方法。</p>
<h4 id="手动创建-deprecated"><a href="#手动创建-deprecated" class="headerlink" title="手动创建(deprecated)"></a>手动创建(deprecated)</h4><p>过程比较繁琐，纯体力活不推荐，大体步骤说下</p>
<ol>
<li>在Xcode中创建一个Cocoa Touch Static Library；</li>
<li>创建Podfile文件；</li>
<li>执行pod install完成整个项目的搭建；<br>如果需要demo，手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行pod install完成示例项目的搭建。</li>
</ol>
<h4 id="基于pod自动创建"><a href="#基于pod自动创建" class="headerlink" title="基于pod自动创建"></a>基于pod自动创建</h4><p>只需要输入pod的lib命令即可完成初始项目的搭建，下面详细说明具体步骤，以WaterDropView作为项目名演示。</p>
<h5 id="1-执行命令pod-lib-create-WaterDropView。在此期间需要确认下面4个问题。"><a href="#1-执行命令pod-lib-create-WaterDropView。在此期间需要确认下面4个问题。" class="headerlink" title="1.执行命令pod lib create WaterDropView。在此期间需要确认下面4个问题。"></a>1.执行命令pod lib create WaterDropView。在此期间需要确认下面4个问题。</h5><pre><code>What language do you want to use?? [ ObjC / Swift ]
&gt; Objc

Would you like to include a demo application with your library? [ Yes / No ]
&gt; Yes

Which testing frameworks will you use? [ Specta / Kiwi / None ]
&gt; None

Would you like to do view based testing? [ Yes / No ]
&gt; No 

What is your class prefix?
&gt; ZM

Running pod install on your new library.

Analyzing dependencies

CocoaPods 0.39.0.beta.4 is available.
To update use: `gem install cocoapods --pre`
[!] This is a test version we&apos;d love you to try.

For more information see http://blog.cocoapods.org
and the CHANGELOG for this version http://git.io/BaH8pQ.

Fetching podspec for `WaterDropView` from `../`
Downloading dependencies
Installing WaterDropView (0.1.0)
Generating Pods project
Integrating client project

[!] Please close any current Xcode sessions and use `WaterDropView.xcworkspace` for this project from now on.

Ace! you&apos;re ready to go!
We will start you off by opening your project in Xcode
open &apos;WaterDropView/Example/WaterDropView.xcworkspace&apos;

To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.
To learn more about creating a new pod, see `http://guides.cocoapods.org/making/making-a-cocoapod`.</code></pre><p>   第一个问题询问是否提供一个demo项目，通常选择Yes，其他的可以根据需要选择。命令执行完后，就会创建好一个通过cocoapods管理依赖关系的基本类库框架。</p>
<h5 id="2-打开WaterDropView-podspec文件，修改类库配置信息，结果像这样。"><a href="#2-打开WaterDropView-podspec文件，修改类库配置信息，结果像这样。" class="headerlink" title="2.打开WaterDropView.podspec文件，修改类库配置信息，结果像这样。"></a>2.打开WaterDropView.podspec文件，修改类库配置信息，结果像这样。</h5><pre><code>#
# Be sure to run `pod lib lint WaterDropView.podspec&apos; to ensure this is a
# valid spec before submitting.
#
# Any lines starting with a # are optional, but their use is encouraged
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
#
Pod::Spec.new do |s|
  s.name             = &quot;WaterDropView&quot;
  s.version          = &quot;0.1.0&quot;
  s.summary          = &quot;A short description of WaterDropView.&quot;

# This description is used to generate tags and improve search results.
#   * Think: What does it do? Why did you write it? What is the focus?
#   * Try to keep it short, snappy and to the point.
#   * Write the description between the DESC delimiters below.
#   * Finally, don&apos;t worry about the indent, CocoaPods strips it!  
  s.description      = &lt;&lt;-DESC
                   DESC

  s.homepage         = &quot;https://github.com/qcc107/WaterDropView&quot;
  # s.screenshots     = &quot;www.example.com/screenshots_1&quot;, &quot;www.example.com/screenshots_2&quot;
  s.license          = &apos;MIT&apos;
  s.author           = { &quot;qcc107&quot; =&gt; &quot;464760435@qq.com&quot; }
  s.source           = { :git =&gt; &quot;https://github.com/qcc107/WaterDropView.git&quot;, :tag =&gt; s.version.to_s }
  # s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos;

  s.platform     = :ios, &apos;7.0&apos;
  s.requires_arc = true

  s.source_files = &apos;Pod/Classes/**/*&apos;
  s.resource_bundles = {
  &apos;WaterDropView&apos; =&gt; [&apos;Pod/Assets/*.png&apos;]
  }

  # s.public_header_files = &apos;Pod/Classes/**/*.h&apos;
  # s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;
  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;
end</code></pre><p>按照默认配置，类库的源文件将位于Pod/Classes文件夹下，资源文件位于Pod/Assets文件夹下，可以修改s.source_files和s.resource_bundles来更换存放目录。s.public_header_files用来指定头文件的搜索位置。<br>s.frameworks和s.libraries指定依赖的SDK中的framework和类库，需要注意，依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成.a或.framework时才能让其他项目正常使用。</p>
<h5 id="3-进入Example文件夹，执行pod-install，让demo项目安装依赖项并更新配置。"><a href="#3-进入Example文件夹，执行pod-install，让demo项目安装依赖项并更新配置。" class="headerlink" title="3.进入Example文件夹，执行pod install，让demo项目安装依赖项并更新配置。"></a>3.进入Example文件夹，执行pod install，让demo项目安装依赖项并更新配置。</h5><pre><code>$pod install

Analyzing dependencies

CocoaPods 0.39.0.beta.4 is available.
To update use: `gem install cocoapods --pre`
[!] This is a test version we&apos;d love you to try.

For more information see http://blog.cocoapods.org
and the CHANGELOG for this version http://git.io/BaH8pQ.

Fetching podspec for `WaterDropView` from `../`
Downloading dependencies
Using WaterDropView (0.1.0)
Generating Pods project
Integrating client project</code></pre><h5 id="4-添加代码。"><a href="#4-添加代码。" class="headerlink" title="4.添加代码。"></a>4.添加代码。</h5><p>添加ZMWaterDropView类，注意文件存放的位置在Pod/Classes目录下，跟podspec配置要一致。<br>运行Pod install，让demo程序加载新建的类。也许你已经发现了，只要新增加类/资源文件或依赖的三方库都需要重新运行Pod install来应用更新。<br>编写Example代码。</p>
<h5 id="提交本地代码库"><a href="#提交本地代码库" class="headerlink" title="提交本地代码库"></a>提交本地代码库</h5><p>1.修改s.source。根据你的实际路径修改。</p>
<p>s.source = { :git =&gt; “/Users/name/workspace/ZMWaterDropView”, :tag =&gt; ‘0.1.0’ }<br>2.提交源码，并打tag。</p>
<p>git add .<br>git commit -a -m ‘v0.1.0’<br>git tag -a 0.1.0 -m ‘v0.1.0’<br>验证类库</p>
<p>开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。可以通过添加–only-errors忽略一些警告。</p>
<p>pod lib lint ZMWaterDropView.podspec –only-errors –verbose<br>…<br>ZMWaterDropView passed validation.<br>打包类库</p>
<p>需要使用一个cocoapods的插件cocoapods-packager来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。</p>
<p>安装打包插件<br>终端执行以下命令</p>
<p>sudo gem install cocoapods-packager<br>打包<br>命令很简单，执行</p>
<p>pod package ZMWaterDropView.podspec –library –force<br>其中–library指定打包成.a文件，如果不带上将会打包成.framework文件。–force是指强制覆盖。需要特别强调的是，该插件通过对引用的三方库进行重命名很好的解决了类库命名冲突的问题。</p>
<hr>
<p>本文参考 <a href="http://code4app.com/article/cocoapods-install-usage" title="code4app" target="_blank" rel="noopener">code4app</a> 和 <a href="http://www.cnblogs.com/brycezhang/archive/2014/11/23/4117180.html" title="Bryce Zhang" target="_blank" rel="noopener">Bryce Zhang</a>。  </p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[阻碍我们成功的八种行为]]></title>
      <url>http://yoursite.com/2015/09/15/%E9%98%BB%E7%A2%8D%E6%88%91%E4%BB%AC%E6%88%90%E5%8A%9F%E7%9A%84%E5%85%AB%E7%A7%8D%E8%A1%8C%E4%B8%BA/</url>
      <content type="html"><![CDATA[<pre><code>你白天黑夜忙个不停，但在事业上却没什么进展。知道吗？可能是你的那些糟糕习惯毁了自己。</code></pre><p>来源：网络</p>
<p> 有时候，我们会是自己最坏的敌人。我们有意或无意中做的事情会阻挠而不是促进我们成功。排除这些具有破坏性的行为的第一步就是认识它们。以下是最糟糕的八种行为：</p>
<h2 id="1-将忙碌与高效混为一谈"><a href="#1-将忙碌与高效混为一谈" class="headerlink" title="1.将忙碌与高效混为一谈"></a>1.将忙碌与高效混为一谈</h2><blockquote>
<p>“不要将行动误当作成就。”——约翰·伍登（John Wooden </p>
</blockquote>
<p>让我们面对这个问题，你能找到足够多的工作让你白天、黑夜和周末都忙个不停。问题是：这些都是应该做的工作吗？</p>
<p>让你成功的并不是你投入了多少小时或者你同时在干几件事，而是专注于有效果的事情。不要把忙碌和取得进展混淆在一起。我们本应评估那些会对我们的目标产生最大影响的行动所取得的进展，而实际上我们却以忙碌程度作为衡量成功的标准。企业文化或许会对“看上去很忙”进行奖励，但企业真正的成功是在追求长期目标的过程中因专注而取得的成果。</p>
<h2 id="2-追求完美"><a href="#2-追求完美" class="headerlink" title="2. 追求完美"></a>2. 追求完美</h2><blockquote>
<p>“如果你追求完美，你永远都不会满足。”——列夫·托尔斯泰（Leo Tolstoy）</p>
</blockquote>
<p>在理想世界中，追求完美不仅高尚，而且会得到回报。在我们生活的这个世界，这是产生挫折感的根源和对时间的巨大浪费。根据心理治疗师梅尔·施瓦兹（Mel Schwartz）的说法：“最接近完美的事物就是能够完全活在当下。没有任何对我们自己进行评估或打分的想法让我们分神，我们自由地活在当下。正是在当下我们才真正活着。然而，完美主义者往往并不活在当下，他们不是忙着批评过去就是反复回想他们的每一个决定或者为他们未来的决定忧心。”</p>
<p>知道什么时候要向前推进，并制定能够取得成果的现实目标。追求完美会让你在前进的道路上停下脚步，或者浪费你原本可以更有成效地用到别处的精力。</p>
<h2 id="3-避免风险"><a href="#3-避免风险" class="headerlink" title="3. 避免风险"></a>3. 避免风险</h2><blockquote>
<p>“没有勇气离开此岸，如何能到达新的彼岸。”——威廉·福克纳（William Faulkner）</p>
</blockquote>
<p>除非你是一位金融界的注册风险管理师（CRM），否则完全规避风险的策略无法让你在职业生涯中取得成功。当然，让你像好莱坞特技演员那样接受风险也不是最有效的办法。你必须接受适度的风险，帮助你学习和成长。没有风险，你会在周围的人事业腾飞之际裹足不前。你应该在是否有助于你达成目标的基础上对风险做出评估，然后坚定地追求那些最有机会让你取得进展的目标。</p>
<h2 id="4-让恐惧阻碍进展"><a href="#4-让恐惧阻碍进展" class="headerlink" title="4. 让恐惧阻碍进展"></a>4. 让恐惧阻碍进展</h2><blockquote>
<p>“船舶停在港湾是安全的，但这并不是造船的目的。”——威廉·G.T. 谢特（William G.T. Shedd）</p>
</blockquote>
<p>恐惧能阻止你前进的步伐。它造成的破坏会导致停滞。它往往出于疯狂的想象，负面的意象远远超出了现实的情况。如果恐惧阻碍了你的进展，那么你需要从转换心境开始。让恐惧成为帮助你迈出重要第一步的动力，而不要让它将你困在起跑线上。</p>
<h2 id="5-被动响应与主动规划"><a href="#5-被动响应与主动规划" class="headerlink" title="5. 被动响应与主动规划"></a>5. 被动响应与主动规划</h2><blockquote>
<p>“不制订计划就是在计划如何失败。”——阿兰·拉金（Alan Lakein）</p>
</blockquote>
<p>成功人士都有计划。他们制订目标、对过程进行规划。他们对成功进行衡量并不时重新校准。如果你发现你每天的大部分工作都是在对其他人的危机做出回应或者回复你收件箱中的任何邮件，那么你是在浪费精力和时间。除非你是在消防部门工作，否则在紧急情况发生后才做出响应，这样的战略不会让你成功。在一堆只会导致你从原定计划上分心的要求把你搞得焦头烂额之际，你有三个工具让自己重回正轨：委派给他人、或礼貌地简短回复，或直接点击“删除”。牢记你的目标。在每天结束时，问问自己你的目标取得了何种进展。</p>
<h2 id="6-修补弱项"><a href="#6-修补弱项" class="headerlink" title="6. 修补弱项"></a>6. 修补弱项</h2><blockquote>
<p>“多年来，我了解到自信的人不会把注意力集中在他们的弱项上——他们最大限度地发挥自己的长处。”——乔伊斯·梅尔（Joyce Meyer）</p>
</blockquote>
<p>如果你的演讲了无生趣，到了台上就紧张不安，而你的目标又是成为销售部门的头，那么你需要继续进行演讲，因为它对你的成功至关重要。然而，大多数弱项并不需要你予以注意和弥补。当你花时间“改进”与你的目标没有关联的弱项时，你挤占了可以取得成效的事情所需的时间。把过多时间花在弱项上将导致平庸。如果你把这些时间用在与你目标有关的优势上并最大程度发挥你的长处，你会精通此项技能，脱颖而出并吸引那些能决定你命运的人的注意就不难了。这是让你走上成功之路的最有效方式。避开平庸之处，专注于你的长项。</p>
<h2 id="7-单干"><a href="#7-单干" class="headerlink" title="7. 单干"></a>7. 单干</h2><blockquote>
<p>“如果勇敢无畏，并且保持专注，一个人的力量会很强大，但很多人合作的力量会更强大。”——格洛丽亚·马卡帕加尔·阿罗约（Gloria Macapagal Arroyo）</p>
</blockquote>
<p>这对我们中的一些人来说是最大的挑战：认为我们无所不能，靠自己可以搞定一切。这个世界上最多才多艺的人却持不同看法。他们身边围绕着一大群人，他们建立起持续终生的伙伴关系，加入全球最顶级专业人士的团体。如果你单干，你唯一的伴侣将是那些你并不擅长或不喜欢干的事情。</p>
<h2 id="8-身边围绕着一群与你相似的人"><a href="#8-身边围绕着一群与你相似的人" class="headerlink" title="8. 身边围绕着一群与你相似的人"></a>8. 身边围绕着一群与你相似的人</h2><blockquote>
<p>“优势在于差异性，而非相似性。”——史蒂芬·科维（Stephen R. Covey）</p>
</blockquote>
<p>身边的人都和你一样而带给你的舒适感受，会产生负面影响。它导致了盲目性，让你通过极为狭隘的视角看待世界。我们都看到过经理人只爱招聘和他们类似的人员，我们身边都有只会说“是”的男同事和女同事。他们让无知指引行动。最成功的领导者会让自己的身边围绕着各种各样的人，这些人挑战他的想法和行动，扩大他的视野并给予他启发，为他带来更加辉煌的成果。</p>
]]></content>
      
        <categories>
            
            <category> 成长中的感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[一个水滴动画的实现]]></title>
      <url>http://yoursite.com/2015/09/14/%E4%B8%80%E4%B8%AA%E6%B0%B4%E6%BB%B4%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>由于项目需求，最近做了一个水滴落下的加载动画。最简单的实现当然是用UIImageView直接播放，但是考虑到动画的帧数太多，会导致整个应用程序包增大，还有水滴落下和水面碰撞的效果不够随机，最后直接用纯代码实现。</p>
<h2 id="波纹的实现"><a href="#波纹的实现" class="headerlink" title="波纹的实现"></a>波纹的实现</h2><p>波浪动画用CAShapeLayer和正弦曲线来模拟，刷新频率为屏幕刷新频率的一半，即30帧每秒。屏幕的刷新用到CADisplayLink,CADisplayLink的精确度优于NSTimer，非常适合这种和屏幕刷新相关的操作。</p>
<h3 id="加载波形层"><a href="#加载波形层" class="headerlink" title="加载波形层"></a>加载波形层</h3><pre><code>- (void)loadWaveLayers{

if (!_waveLayers) 
{
    self.waveLayers = [[NSMutableArray alloc] initWithCapacity:3];

    UIColor *whiteColor = [UIColor whiteColor];
    UIColor *lightGrayColor = [UIColor colorWithRed:207/255.0f
                                              green:207/255.0f
                                               blue:207/255.0f
                                              alpha:1.0f];
    UIColor *darkGrayColor = [UIColor colorWithRed:159/255.0f
                                             green:159/255.0f
                                              blue:159/255.0f
                                             alpha:1.0f];

    NSArray *colors = @[darkGrayColor, lightGrayColor, whiteColor];

    for (int i = 0; i &lt; 3; ++i) {
        CAShapeLayer *waveLayer = [CAShapeLayer layer];
        waveLayer.fillColor = ((UIColor *)colors[i]).CGColor;
        [self.layer addSublayer:waveLayer];

        [_waveLayers addObject:waveLayer];
    }
}
}</code></pre><h3 id="设置定时器"><a href="#设置定时器" class="headerlink" title="设置定时器"></a>设置定时器</h3><pre><code>_frameTimer = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateVibrations:)];
_frameTimer.frameInterval = 2;
[_frameTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</code></pre><h3 id="更新数值"><a href="#更新数值" class="headerlink" title="更新数值"></a>更新数值</h3><pre><code>- (void)updateVibrations:(CADisplayLink *)displayLink
{
if (_increase) {
    _variable += 1 / 30.0f;
}else{
    _variable -= 1 / 30.0f;
}

if (_variable &lt;= 1) {
    _increase = YES;
}

if (_variable &gt;= 1.6) {
    _increase = NO;
}

_offsetX += _waveSpeed;

[self drawWaveWithLayer:_waveLayers[0] amplitude:_variable * 3 waveCycle:1.5* M_PI / _waveWidth offsetY:20.0f];    // dark
[self drawWaveWithLayer:_waveLayers[1] amplitude:_variable * 5 waveCycle:1.1 * M_PI / _waveWidth offsetY:22.0f];   // light
[self drawWaveWithLayer:_waveLayers[2] amplitude:_variable * 10 waveCycle:1 * M_PI / _waveWidth offsetY:22.0f];    // white
}</code></pre><h3 id="绘制正弦曲线"><a href="#绘制正弦曲线" class="headerlink" title="绘制正弦曲线"></a>绘制正弦曲线</h3><pre><code> - (void)drawWaveWithLayer:(CAShapeLayer *)waveLayer
           amplitude:(CGFloat)amplitude
           waveCycle:(CGFloat)waveCycle
             offsetY:(CGFloat)offsetY
{
   CGMutablePathRef path = CGPathCreateMutable();
   CGFloat y = self.bounds.size.height * 0.5f;
   CGPathMoveToPoint(path, nil, 0, y);

   for (float x = 0.0f; x &lt;=  _waveWidth ; x++) {
       y = amplitude * sin(waveCycle * x + _offsetX) + self.frame.size.height * 0.5f + offsetY;   // 正弦波
       CGPathAddLineToPoint(path, nil, x, y);
   }

   CGPathAddLineToPoint(path, nil, _waveWidth, self.frame.size.height);
   CGPathAddLineToPoint(path, nil, 0, self.frame.size.height);
   CGPathCloseSubpath(path);

   waveLayer.path = path;
   CGPathRelease(path);
}</code></pre><h2 id="绘制水滴"><a href="#绘制水滴" class="headerlink" title="绘制水滴"></a>绘制水滴</h2><h3 id="绘制水滴的视图"><a href="#绘制水滴的视图" class="headerlink" title="绘制水滴的视图"></a>绘制水滴的视图</h3><p>自定义一个View继承自UIView,在drawRect中实现：</p>
<pre><code>- (void)drawRect:(CGRect)rect {
// Drawing code

CGContextRef context = UIGraphicsGetCurrentContext();

CGContextMoveToPoint(context, self.bounds.size.width * 0.5f, 0);

[[UIColor whiteColor] set];
CGContextSetLineWidth(context, 1.0);

CGContextAddCurveToPoint(context,
                         0,
                         self.bounds.size.height,
                         self.bounds.size.width,
                         self.bounds.size.height,
                         self.bounds.size.width * 0.5f,
                         0);

CGContextSetFillColorWithColor(context,[UIColor whiteColor].CGColor);
CGContextFillPath(context);

CGContextStrokePath(context);
}</code></pre><p>   这里要保证水滴视图的宽高比为2：1，这样贝塞尔曲线绘制出来的才是水滴形状。</p>
<h3 id="给水滴添加重力和碰撞检测"><a href="#给水滴添加重力和碰撞检测" class="headerlink" title="给水滴添加重力和碰撞检测"></a>给水滴添加重力和碰撞检测</h3><p>这里用到了UIKit动力学。</p>
<pre><code>UIGravityBehavior *gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[_dripView]];
[_animator addBehavior:gravityBeahvior];

UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc] initWithItems:@[_dripView]];
collisionBehavior.translatesReferenceBoundsIntoBoundary = NO;

CGPoint rightEdge = CGPointMake(_barrierLine.frame.origin.x + _barrierLine.frame.size.width,
                                _barrierLine.frame.origin.y);

[collisionBehavior addBoundaryWithIdentifier:@&quot;barrier&quot;
                            fromPoint:_barrierLine.frame.origin
                              toPoint:rightEdge];
collisionBehavior.collisionDelegate = (id)self;
[_animator addBehavior:collisionBehavior];


UIDynamicItemBehavior *itemBehaviour = [[UIDynamicItemBehavior alloc] initWithItems:@[_dripView, _barrierLine]];
itemBehaviour.elasticity = 0.0;
[_animator addBehavior:itemBehaviour];</code></pre><h2 id="水滴和波浪碰撞后的喷溅效果"><a href="#水滴和波浪碰撞后的喷溅效果" class="headerlink" title="水滴和波浪碰撞后的喷溅效果"></a>水滴和波浪碰撞后的喷溅效果</h2><h3 id="创建圆形水珠"><a href="#创建圆形水珠" class="headerlink" title="创建圆形水珠"></a>创建圆形水珠</h3><pre><code>- (void)splashWater
{
if (!_dripLayers) {
    _dripLayers = [[NSMutableArray alloc] initWithCapacity:kDripCount];

    for (int i = 0; i &lt; kDripCount; i++) {

        CALayer *dripLayer = [CALayer layer];
        [_dripLayers addObject:dripLayer];

    }
}

for (int i = 0; i &lt; kDripCount; i++) {

    [self performSelector:@selector(addAnimationToDrip:) withObject:_dripLayers[i] afterDelay:i * 0.01];
}
}</code></pre><h3 id="给水珠添加抛物线动画"><a href="#给水珠添加抛物线动画" class="headerlink" title="给水珠添加抛物线动画"></a>给水珠添加抛物线动画</h3><pre><code>- (void)addAnimationToDrip:(CALayer *)dripLayer
{
CGFloat width = arc4random() % 15 + 1;
dripLayer.frame = CGRectMake((self.bounds.size.width - width)* 0.5f, self.bounds.size.height * 0.5f + 40, width, width);
dripLayer.cornerRadius = dripLayer.frame.size.width * 0.5f;
dripLayer.backgroundColor = [UIColor whiteColor].CGColor;

[self.layer addSublayer:dripLayer];

CGFloat x3 = arc4random() % ((int)self.bounds.size.width) + 1;
CGFloat y3 = self.bounds.size.height * 0.5f + 40;

CGFloat height = arc4random() % ((int)(self.bounds.size.height * 0.5f));

[self throwDrip:dripLayer
           from:dripLayer.position
             to:CGPointMake(x3, y3)
         height:height
       duration:0.7f];
 }


 - (void)throwDrip:(CALayer *)drip
         from:(CGPoint)start
           to:(CGPoint)end
       height:(CGFloat)height
     duration:(CGFloat)duration
{

CGMutablePathRef path = CGPathCreateMutable();

CGPathMoveToPoint(path, NULL, start.x, start.y);
CGPathAddQuadCurveToPoint(path, NULL, (end.x + start.x) * 0.5f, -height, end.x, end.y);

CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
[animation setPath:path];
animation.duration = duration;
CFRelease(path);
path = nil;Demotic

[drip addAnimation:animation forKey:@&quot;position&quot;];
}</code></pre><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/qcc107/WaterDropDemo.git" target="_blank" rel="noopener">WaterDropDemo</a></p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS中的仿射变换]]></title>
      <url>http://yoursite.com/2015/09/06/iOS%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>   在开发中我们有时需要对视图做旋转和缩放，iOS提供了三种仿射变换：平移、旋转、和缩放。</p>
<h2 id="一、仿射变换"><a href="#一、仿射变换" class="headerlink" title="一、仿射变换"></a>一、仿射变换</h2><p>   每个仿射变换可以由一个矩阵A和一个向量b给出，它可以写作A和一个附加的列b。一个仿射变换对应于一个矩阵和一个向量的乘法，而仿射变换的复合对应于普通的矩阵乘法。</p>
<h3 id="CGAffineTransform结构体"><a href="#CGAffineTransform结构体" class="headerlink" title="CGAffineTransform结构体"></a>CGAffineTransform结构体</h3><pre><code>struct CGAffineTransform {
  CGFloat a, b, c, d;
  CGFloat tx, ty;
};</code></pre><p>CGAffineTransform实际上是一个矩阵</p>
<pre><code>| a,  b,  0 |
| c,  d,  0 |
| tx, ty, 1 |</code></pre><p>这个矩阵是用来标记这个View的变化，可以是旋转，缩放，平移。<br>也就是说，View的坐标为 {x,y}，变化后的坐标是{x’,y’}</p>
<pre><code>                    | a,  b,  0 |
{x&apos;,y&apos;,1}={x,y,1} x | c,  d,  0 |
                    | tx, ty, 1 |</code></pre><h2 id="二、创建Transformations"><a href="#二、创建Transformations" class="headerlink" title="二、创建Transformations"></a>二、创建Transformations</h2><h3 id="1、直接创-建"><a href="#1、直接创-建" class="headerlink" title="1、直接创 建"></a>1、直接创 建</h3><p>使用CGAffineTransformMake函数</p>
<pre><code>CGAffineTransform CGAffineTransformMake (
   CGFloat a,
   CGFloat b,
   CGFloat c,
   CGFloat d,
   CGFloat tx,
   CGFloat ty
   );</code></pre><p>参数比较多，很少使用。</p>
<h3 id="2、创建缩放变换"><a href="#2、创建缩放变换" class="headerlink" title="2、创建缩放变换"></a>2、创建缩放变换</h3><p>使用CGAffineTransformMakeScale函数</p>
<pre><code>CGAffineTransform CGAffineTransformMakeScale (CGFloat sx, CGFloat sy);</code></pre><p>sx为宽度缩放因子，sy为高度缩放因子。假设是一个图片视图引用了这个变换，那么图片的宽度就会变为 width*sx ，对应高度变为 hight * sy。</p>
<h3 id="3、创建旋转变换"><a href="#3、创建旋转变换" class="headerlink" title="3、创建旋转变换"></a>3、创建旋转变换</h3><p>使用CGAffineTransformMakeRotation函数</p>
<pre><code>CGAffineTransform CGAffineTransformMakeRotation ( CGFloat angle);</code></pre><p>以弧度为参数，表示要旋转的度数。</p>
<h3 id="4、创建平移变换"><a href="#4、创建平移变换" class="headerlink" title="4、创建平移变换"></a>4、创建平移变换</h3><p>使用CGAffineTransformMakeTranslation函数</p>
<pre><code>CGAffineTransform CGAffineTransformMakeTranslation (CGFloat tx,CGFloat ty);</code></pre><p>设置一个视图的transform属性，那么它的起始位置 x 会加上tx , y 会加上 ty</p>
<h2 id="三、修改Transformations"><a href="#三、修改Transformations" class="headerlink" title="三、修改Transformations"></a>三、修改Transformations</h2><h3 id="1、对传入的变换加上平移"><a href="#1、对传入的变换加上平移" class="headerlink" title="1、对传入的变换加上平移"></a>1、对传入的变换加上平移</h3><p>CGAffineTransformTranslate</p>
<pre><code>CGAffineTransform CGAffineTransformTranslate (
    CGAffineTransform t,
    CGFloat tx,
    CGFloat ty
 );</code></pre><h3 id="2、对传入的变换加上缩放"><a href="#2、对传入的变换加上缩放" class="headerlink" title="2、对传入的变换加上缩放"></a>2、对传入的变换加上缩放</h3><p>CGAffineTransformScale</p>
<pre><code>CGAffineTransform CGAffineTransformScale (
    CGAffineTransform t,
    CGFloat sx,
    CGFloat sy
);</code></pre><h3 id="3、对传入的变换加上旋转"><a href="#3、对传入的变换加上旋转" class="headerlink" title="3、对传入的变换加上旋转"></a>3、对传入的变换加上旋转</h3><p>CGAffineTransformRotate </p>
<pre><code>CGAffineTransform CGAffineTransformRotate (
    CGAffineTransform t,
    CGFloat angle
);</code></pre><h3 id="4、反转传入的变换"><a href="#4、反转传入的变换" class="headerlink" title="4、反转传入的变换"></a>4、反转传入的变换</h3><p>CGAffineTransformInvert</p>
<pre><code>CGAffineTransform CGAffineTransformInvert (CGAffineTransform t);</code></pre><h3 id="5、合并两个变换"><a href="#5、合并两个变换" class="headerlink" title="5、合并两个变换"></a>5、合并两个变换</h3><p>CGAffineTransformConcat</p>
<pre><code>CGAffineTransform CGAffineTransformConcat (CGAffineTransform t1, CGAffineTransform t2);</code></pre><p>返回一个由 t1 和 t2 合并而成的Transformation</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[拆掉思维里的墙经典语录]]></title>
      <url>http://yoursite.com/2015/09/03/%E6%8B%86%E6%8E%89%E6%80%9D%E7%BB%B4%E9%87%8C%E7%9A%84%E5%A2%99%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/</url>
      <content type="html"><![CDATA[<h5 id="你是否缺少安全感？你会经常觉得累吗？结婚一定要买房吗？坚持一定会成功吗？努力一定有结果？只有有钱才能够幸福？老板可以掌控吗？小人物就无法对抗不公平吗？你对如今的生活不满意，但却因为父母、老婆或者孩子不得不这样过下去吗？每天都在混日子，却幻想有一天找到自己真正喜欢的事业就一定会全心投入？……如果有一个回答是“YES”，那么这本书就是你想要的。也许，连我们自己也不曾意识到，那些困惑背后，往往藏着一堵堵思维里的墙，阻碍着我们，把我们与美好的生活隔开了。拆掉思维里的那些墙，你就可以获得成功、快乐、自信和幸福。从“IMPOSSIBLE”到“I’M-POSSIBLE”，只须一点改变，你的人生也许就此大不相同。我们应该冲出牢笼，努力投资自己，哪怕工资不高，也要拿出一部分资金来强大自己，让自己更有价值。也不要因为职业安全感把自己困住，走出去追求自己想要的生活。"><a href="#你是否缺少安全感？你会经常觉得累吗？结婚一定要买房吗？坚持一定会成功吗？努力一定有结果？只有有钱才能够幸福？老板可以掌控吗？小人物就无法对抗不公平吗？你对如今的生活不满意，但却因为父母、老婆或者孩子不得不这样过下去吗？每天都在混日子，却幻想有一天找到自己真正喜欢的事业就一定会全心投入？……如果有一个回答是“YES”，那么这本书就是你想要的。也许，连我们自己也不曾意识到，那些困惑背后，往往藏着一堵堵思维里的墙，阻碍着我们，把我们与美好的生活隔开了。拆掉思维里的那些墙，你就可以获得成功、快乐、自信和幸福。从“IMPOSSIBLE”到“I’M-POSSIBLE”，只须一点改变，你的人生也许就此大不相同。我们应该冲出牢笼，努力投资自己，哪怕工资不高，也要拿出一部分资金来强大自己，让自己更有价值。也不要因为职业安全感把自己困住，走出去追求自己想要的生活。" class="headerlink" title="你是否缺少安全感？你会经常觉得累吗？结婚一定要买房吗？坚持一定会成功吗？努力一定有结果？只有有钱才能够幸福？老板可以掌控吗？小人物就无法对抗不公平吗？你对如今的生活不满意，但却因为父母、老婆或者孩子不得不这样过下去吗？每天都在混日子，却幻想有一天找到自己真正喜欢的事业就一定会全心投入？……如果有一个回答是“YES”，那么这本书就是你想要的。也许，连我们自己也不曾意识到，那些困惑背后，往往藏着一堵堵思维里的墙，阻碍着我们，把我们与美好的生活隔开了。拆掉思维里的那些墙，你就可以获得成功、快乐、自信和幸福。从“IMPOSSIBLE”到“I’M POSSIBLE”，只须一点改变，你的人生也许就此大不相同。我们应该冲出牢笼，努力投资自己，哪怕工资不高，也要拿出一部分资金来强大自己，让自己更有价值。也不要因为职业安全感把自己困住，走出去追求自己想要的生活。"></a>你是否缺少安全感？你会经常觉得累吗？结婚一定要买房吗？坚持一定会成功吗？努力一定有结果？只有有钱才能够幸福？老板可以掌控吗？小人物就无法对抗不公平吗？你对如今的生活不满意，但却因为父母、老婆或者孩子不得不这样过下去吗？每天都在混日子，却幻想有一天找到自己真正喜欢的事业就一定会全心投入？……如果有一个回答是“YES”，那么这本书就是你想要的。也许，连我们自己也不曾意识到，那些困惑背后，往往藏着一堵堵思维里的墙，阻碍着我们，把我们与美好的生活隔开了。拆掉思维里的那些墙，你就可以获得成功、快乐、自信和幸福。从“IMPOSSIBLE”到“I’M POSSIBLE”，只须一点改变，你的人生也许就此大不相同。我们应该冲出牢笼，努力投资自己，哪怕工资不高，也要拿出一部分资金来强大自己，让自己更有价值。也不要因为职业安全感把自己困住，走出去追求自己想要的生活。</h5><ul>
<li><p>1、对于大多数刚走入社会的人来说，一套房子就能消灭一个梦想。</p>
</li>
<li><p>2、安全感不是拿回来，而是给回来的。</p>
</li>
<li><p>3、无趣之人，往往是无胆之人。孩子对学习“不感兴趣”，往往是由于自己觉得没有学好的能力，或者再怎么努力也达不到父母的要求；老人们对任何事情都 “不感兴趣”，是因为他们觉得自己能力不足，或者怎么做都没有年轻人做的好。但是没有人愿意说我很害怕，所以他们骗自己说，我根本不感兴趣！</p>
</li>
<li><p>4、为什么很多有钱人一点也不快乐？因为当他们有了钱之后才发现，钱根本不是他们想追求的。</p>
</li>
<li><p>5、坚持一定会成功吗？答案是错，这是成功学一贯的理念，如果坚持能成功的话，苦追刘德华的杨丽娟就会成为刘德华的老婆的。</p>
</li>
<li><p>6、与其在等待中枯萎，不如在行动中绽放。</p>
</li>
<li><p>7、花费你的一部分过去，去购买一个未来。</p>
</li>
<li><p>8、别用自己的生命点燃别人眼中的光环。</p>
</li>
<li><p>9、你的潜能就好像你的咨询顾问，如果一开始你信任他，他就会越来越努力，为你做越来越多的事情。但是如果你一开始就不信任他，而去依赖其他的东西，他就会慢慢远离你，在你需要用的时候，他再也不会再来。</p>
</li>
<li><p>10、恐惧就是这样一个懦夫，当你触及他的底线，接受事情最坏的结果，然后开始准备和它大干一场的时候，它早就不知道躲到哪里去了。</p>
</li>
<li><p>11、一个成功的职业发展人士，十年后一个月的收入是十年前一年收入的十倍。</p>
</li>
<li><p>12、在今天这个变化多端的社会，期待一个公司或者行业连续10年都有最快的发展，怎么可能呢？自我的快速发展，也许需要通过调整职业方向的方式来实现。而房贷却让我们不敢做任何的职业变动。</p>
</li>
<li><p>13、以今天的房价，排除那些富二代不说，普通人买房只有两种情况，一种是双方父母出钱资助，这种人的前途和发展基本上被父母控股了。第二种人是牺牲了太多的发展机会，典当梦想来成就一套房子。</p>
</li>
<li><p>14、爱有两种，一种是死死抓住，你紧张他也紧张；一种是轻松拖住，你舒服他也舒服。</p>
</li>
<li><p>15、安全感绝对不是来自婚姻，如果你是抱着想要安全感而进入婚姻的话，这个婚姻80%会出现问题。</p>
</li>
<li><p>16、我没有一个人活下去的勇气，没有你我怎么办，干得好不如嫁得好。这些天天围绕在我们身边的屁话，你真的相信吗？其实说出这些话的人都是没有安全感的人。</p>
</li>
<li><p>17、你是否给爱人发过短信“小红，我爱你。”然后拿着手机焦急的等待，一分钟看一次，你在等待对方的回复“小明，我也爱你”。其实这不是爱，而是索 取，真正的爱的表达不是期望得到对方同等的回复，不要把爱自己当成爱别人。那些打着爱的旗号的伤人者、自残者、伟大牺牲者，没有发现，那其实不是爱，而是 恐惧。</p>
</li>
<li><p>18、我们很多时候把依赖当成了爱，当看到别人没有自己也活得很好的时候，内心就会莫名其妙的生气，觉得对方不爱自己了。其实真正的爱，是给对方自由，也给自己自由。</p>
</li>
<li><p>19、你的父母有没有对你说过：“我这样为了你，你却让我这么伤心。”这些话听上去是爱的表达，其实是一种要求与责备。翻译过来就是：“我对你这么好，所以你必须听我的话！”</p>
</li>
<li><p>20、你的孩子得了100分，你很高兴，对他说：“你得了一百分，妈妈好爱你啊！”但当他得60分的时候，你又会说什么呢？你会不会生气地说：“怎么这么低？妈妈不喜欢你了！”你的孩子很快就会学会：妈妈爱的不是我，而是我的分数。他也会把“喜欢”和“爱”混为一谈。</p>
</li>
<li><p>21、能力=天赋*时间，如果有一件事你没有成功，那不一定是欠缺天赋，而是欠缺时间。</p>
</li>
<li><p>22、不相信自己，又随时害怕失去。我们终将被奴役，成为安全感的奴隶。</p>
</li>
<li><p>23、在安全的环境，拆掉思维里的墙，小范围地冒一冒险吧！试试看只用你们家房子的一平方米的钱，给自己安排一段旅游；试试看在一两个你永远不再去也不可惜的小群体里面做做自己一直不好意思做的事；试试看给那些可去可不去的职位打电话，试着推销一下自己试试看……</p>
</li>
<li><p>24、远离那些让你容易获得安全感的事情！包括过于关心你的父母、一张可以任意刷的卡、一个不会犯错误的任务和一个养老般的工作。那会驯化你成为安全感奴隶！</p>
</li>
<li><p>25、给自己一个恐惧保险箱，你会发现，你曾经担心的那些东西，几乎从来没有发生过。</p>
</li>
<li><p>26、很多人害怕公众演讲，其实，你真正恐惧的不是讲砸，而是自己没有能力面对讲砸的状况，这才是你内心深处的不自信与恐惧。</p>
</li>
<li><p>27、背对恐惧最可怕，当你真的转过脸去面对，会发现其实没有什么好怕的。</p>
</li>
<li><p>28、你有没有被逼到命运的墙角？有没有试过触碰想都不敢想的事情的底线？那请记得问自己：如果我失败了，新来了一个家伙/新的情况下，我会怎么办？</p>
</li>
<li><p>29、你有没有注意到，安全感不是从别人身上要什么，而是内心深处，一种被需要的感觉？你有没有注意到，安全感不是从别人身上拿到些什么，而是为这个世界给予些什么？你有没有注意到，安全感是给出来的，而不是要回来的呢？</p>
</li>
<li><p>30、我们在吃饭时想着工作，在工作时想着出错，在恋爱时担心分手，在拥抱时还在看表……我们不能在适当的时间做专一的事，所以我们还是凡人一个。</p>
</li>
<li><p>31、乐趣来源于全情投入，而不是投入后的结果，正是因为这样，乐趣可以是无条件的。</p>
</li>
<li><p>32、一个婴儿在玩的时候咯咯地笑，并不是因为这个游戏会让他获得什么。我们在演奏乐器时觉得开心，并不是因为我们要通过这个拿到钢琴十级。我们在听笑 话的时候哈哈大笑，并不是因为我们要记录下来炫耀给别人。我们看小说时觉得心向往之，并不是因为这本小说能让我减压。因为快乐就是快乐，投入的快乐是无条 件的。</p>
</li>
<li><p>33、当你真正完全投入到当下的事情中去时，不管这个事情多么简单卑微，你都能感受到无穷的乐趣。任何一个瑜伽教练都会告诉你，即使认真地投入你的呼吸——这个每天你做过无数次的事情——都能感受到无数的乐趣。</p>
</li>
<li><p>34、不计较钱多钱少肯认真工作的人，往往觉得只要是能从事这份工作，本身就是对他的最大报酬。事实上，当一个人为了工作本身而不是工作后的工资来做事情的时候，他往往能够把工作做到最好，也一定会收到最多的报酬。</p>
</li>
<li><p>35、生命就好像镜子一样，有趣之人对生活保持着极高的投入度，全力拥抱，生活也全力拥抱他。无趣之人用“没兴趣”把自己和生命隔绝，所以生命也躲开他。</p>
</li>
<li><p>36、寻找那些不能够被满足的深层兴趣，比如爱、成长、超越自己、快乐、助人、宁静……它们会让你幸福一辈子。</p>
</li>
<li><p>37、成功的尝试能收获到成果，不成功的尝试能收获到智慧。</p>
</li>
<li><p>38、什么是快乐？就是做事情既快，又乐！</p>
</li>
<li><p>39、对什么都“不感兴趣”的人，害怕冒险，害怕失败，所以压根不投入，不投入就难以获得成果，哪怕是一点点的进步。当一个人对自己的生命开始用“不感兴趣”来搪塞时，生命也开始对他不感兴趣了。</p>
</li>
<li><p>40、带着关爱而不是期待的投入生活，你会发现能力与乐趣接踵而来。</p>
</li>
<li><p>41、为你的生命找到一个长期的、深层的、不能被满足的乐趣。让这个永恒乐趣带领你穿透生命的无常。</p>
</li>
<li><p>42、我们就是自己生命的巫师，我们给自己搭建一个幻想世界，然后在现实中让这个幻想慢慢实现。</p>
</li>
<li><p>43、如果你是金子，你要提高你的含金量到一定程度，才会成为金矿。当你被挖掘出来，你要经过很痛苦的碾磨、冲刷、浸泡，要让你身上的杂质，不好的习惯、污点被熔掉。然后还要成型、打磨、抛光，最后才成为很有价值的发光的金子！</p>
</li>
<li><p>44、人们宁愿自我欺骗，也不愿意相信自己是被欺骗的。因为他活在自己的思维之墙当中。</p>
</li>
<li><p>45、“道”是不会改变的，而“法”会简单地改变，至于做事情的方式“术”，就会经常地改变。</p>
</li>
<li><p>46、一件事情的价值，不取决于现在你判断的价值，而取决于在未来情况中的价值，这就叫做未来价值。懂得静观大地开花结果的人，决不会为失去的一切而痛心。</p>
</li>
<li><p>47、沉没成本其实就是已经损失的成本，为了这个损失而追加成本，最后只头破血流。害怕损失的人，损失最大。</p>
</li>
<li><p>48、有目标的人穿越困难航行，无目标的人躲避困难漂泊。航行者一直在接近目标，漂泊者一直在逃离恐惧。</p>
</li>
<li><p>49、爱害者最擅长的两件事：这不关我事，那不关我事。当然他们也没有做过任何事。他们每一个人都在别人的受害者故事中获得不少廉价的快乐。其实是因为受害者深深坚信，自己快乐与否、成功与否掌握在他人手中。</p>
</li>
<li><p>50、你的生命就像你的家。因为你的不坚持，却让别人进来布置。但是你不要忘了，在里面住一辈子的还是你自己民。所以让你的父母停止质疑的最好方式，就是尽快开始 的行动，然后用事实证明给他们看！你不妨把自己的梦想想象成一家上市公司的董事会，你和你的父母对于“你”这个公司都有一定的发言权。他们占有一定的股 份。他们有权利发言，有权利表达观点，而你也有义务认真倾听、考虑。但记得在关于你人生的董事会上，你永远是最大的股东。</p>
</li>
<li><p>51、我们很听话地长成为一群有脑无心的人，一群有逻辑没情感的人，一群讲高度不讲尊重的人。我们长成为别人要求的样子，并且以此为荣。就这样，我们把自己弄丢了。</p>
</li>
<li><p>52、当一个人等待与拖延的成本，远远高于他真正开始行动所需要的成本，他就会慢慢陷入越等待越不行动的怪圈。我把这个模式称为“等死模式”。</p>
</li>
<li><p>53、什么是成长？那是你内心的一个尺度。你能够感觉到你的成长，你内心知道你会成长为什么样子，就好像一棵橡树籽，无需教导，也会成长为一棵挺拔的橡树。世界上每一个人都可以成长为自己最好的样子，同时我们也拥有关于成长为这个样子所有的资源。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 成长中的感悟 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[UNIX编程艺术之策略与机制相分离]]></title>
      <url>http://yoursite.com/2015/09/01/UNIX%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%AD%96%E7%95%A5%E4%B8%8E%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>categories: </p>
<ul>
<li>IT随笔</li>
</ul>
<p>在现代操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造OS结构。所谓机制，是指实现某一功能的具体执行机构。而策略，则是在机制的基础上，借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。</p>
<p>在程序设计中，机制与策略分离的思想可以提高程序的可复用性，可维护性和可调试性使程序更具有高内聚低耦合性。如果说机制是砖，那么策略就是房子，同样的砖可以建不同的房子，我们不能把建砖和建房子混在一起实现，所以，把策略同机制揉成一团有两个负面影响：一来会使策略变得死板，难以适应用户需求的改变，二来也意味着任何策略的改变都极有可能动摇机制。</p>
<p>策略的变化要远远大于机制的变化。将两者分离，可以使机制相对保持稳定，而同时支持策略的变化。</p>
<p>这条准则在GUI环境之外也被广泛应用。总而言之，这条准则告诉我们要将接口和引擎剥离开来。</p>
<p>UIView继承自UIResponder，主要特点是可以响应触摸事件。CALayer专司图层内容管理和绘制。CALayer是机制，在系统中属于不可变部分，UIView属于策略，在系统中属于可变部分。构建一个系统要尽肯能分离可变部分和不可变部分。</p>
<p>在代码大全中提到“隔离变化”的概念，以及设计模式中提到的将易变化的部分和不易变化的部分分离也是这个思路。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[S.O.L.I.D.类设计原则]]></title>
      <url>http://yoursite.com/2012/07/25/S-O-L-I-D-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>   本文是由敏捷宣言签署人之一、《 Clean Code(代码整洁之道)》一书的作者Robert C. Martin为他的《Applying Principles and Patterns》这本书搜集整理而来。</p>
<h2 id="单一责任原则-SRP"><a href="#单一责任原则-SRP" class="headerlink" title="单一责任原则(SRP)"></a>单一责任原则(SRP)</h2><p>只有一个理由去修改一个类。例如，如果一个业务规则的改变会导致这个类的修改，那么，数据库、界面、报表格式或系统任何其它的部分的改变都不该迫使这个类做修改。</p>
<h2 id="开发-关闭原则-OCP"><a href="#开发-关闭原则-OCP" class="headerlink" title="开发/关闭原则(OCP)"></a>开发/关闭原则(OCP)</h2><p>软件构成(类，模块，方法等)向扩展行为开放，向修改行为关闭。</p>
<h2 id="Liskov替换原则-LSP"><a href="#Liskov替换原则-LSP" class="headerlink" title="Liskov替换原则(LSP)"></a>Liskov替换原则(LSP)</h2><p>子类必须能够用来当作基类使用。如果类A继承类B，任何能使用A的地方，B也同样可以使用。例如，是否还记得，正方形可以看作是矩形！当进行扩展 时：前提条件不许绕过，后置条件不能放宽限制，可见常量不能被修改(?)。常量：在扩展之前或之后，用户都需要依靠这个常量来传递信息。正确的使用set 形式的继承关系。不遵守set语义是非常危险的。归纳：使用超类的引用的任何上下文中也可以使用其子类的引用替代。这个原则极大的限制了在纯扩展(继承) 机制里可以做的事情。不遵守会带来风险。</p>
<h2 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则(ISP)"></a>接口分离原则(ISP)</h2><p>一个类对另一个类的依赖应该限制在最小化的接口上。</p>
<h2 id="反向依赖原则-DIP"><a href="#反向依赖原则-DIP" class="headerlink" title="反向依赖原则(DIP)"></a>反向依赖原则(DIP)</h2><p>依赖抽象层(接口)，而不是具体类。</p>
]]></content>
      
        <categories>
            
            <category> IT随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
